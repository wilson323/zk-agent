# å¼€å‘ä»»åŠ¡è¯¦ç»†åˆ†è§£æ–‡æ¡£

## ğŸ¯ é¡¹ç›®æ€»ä½“ç›®æ ‡

æ„å»ºä¸–ç•Œçº§çš„AIæ™ºèƒ½ä½“å¹³å°ï¼Œæ•´åˆæœ€ä¼˜ç§€çš„CADåˆ†æåŠŸèƒ½ï¼Œå®ç°è·¨å¹³å°å“åº”å¼è®¾è®¡ï¼Œç¡®ä¿ç”Ÿäº§çº§äº¤ä»˜æ ‡å‡†ã€‚

## ğŸš¨ æ ¸å¿ƒå¼€å‘åŸåˆ™ï¼ˆå¼ºåˆ¶æ‰§è¡Œï¼‰

### åŸºäºç°æœ‰ä»£ç ä¼˜åŒ–çš„æ ¸å¿ƒåŸåˆ™
> **å…³é”®è¦æ±‚ï¼šå°½å¯èƒ½åŸºäºç°æœ‰ä»£ç è¿›è¡Œä¼˜åŒ–è°ƒæ•´ï¼Œç¡®ä¿æ²¡æœ‰ä»£ç å†—ä½™ï¼Œæ˜¯åœ¨æœ¬ç³»ç»Ÿä¸Šä¼˜åŒ–è€Œä¸æ˜¯æ–°å»ºä¸€ä¸ªç³»ç»Ÿ**

#### å®æ–½è¦æ±‚ï¼š
1. **æ‰©å±•è€Œéé‡å»º** - åœ¨ç°æœ‰ç»„ä»¶åŸºç¡€ä¸Šæ·»åŠ åŠŸèƒ½ï¼Œä¸åˆ›å»ºé‡å¤ç»„ä»¶
2. **ç»§æ‰¿ç°æœ‰æ¶æ„** - éµå¾ªç°æœ‰çš„æ–‡ä»¶ç»“æ„å’Œå‘½åè§„èŒƒ
3. **å¤ç”¨ç°æœ‰é€»è¾‘** - ä¼˜å…ˆä½¿ç”¨å·²æœ‰çš„å·¥å…·å‡½æ•°å’ŒæœåŠ¡
4. **ä¿æŒæ¥å£ä¸€è‡´** - æ–°åŠŸèƒ½è¦ä¸ç°æœ‰APIä¿æŒå…¼å®¹
5. **æ¸è¿›å¼å¢å¼º** - æ–°åŠŸèƒ½å¯ä»¥ç‹¬ç«‹å¼€å…³ï¼Œä¸å½±å“ç°æœ‰åŠŸèƒ½

#### ä»£ç å®æ–½æ£€æŸ¥ï¼š
- [ ] **ç»„ä»¶æ‰©å±•**ï¼šæ˜¯å¦åŸºäºç°æœ‰ç»„ä»¶è¿›è¡ŒåŠŸèƒ½æ‰©å±•ï¼Ÿ
- [ ] **æœåŠ¡å¤ç”¨**ï¼šæ˜¯å¦å¤ç”¨äº†ç°æœ‰çš„æœåŠ¡å’Œå·¥å…·å‡½æ•°ï¼Ÿ
- [ ] **æ¥å£å…¼å®¹**ï¼šæ–°åŠŸèƒ½æ˜¯å¦ä¿æŒAPIæ¥å£å‘åå…¼å®¹ï¼Ÿ
- [ ] **é…ç½®é©±åŠ¨**ï¼šå¢å¼ºåŠŸèƒ½æ˜¯å¦å¯ä»¥é€šè¿‡é…ç½®å¼€å…³æ§åˆ¶ï¼Ÿ
- [ ] **æµ‹è¯•ä¿æŒ**ï¼šç°æœ‰æµ‹è¯•æ˜¯å¦ä»ç„¶é€šè¿‡ï¼Ÿ

## ğŸ“Š ä»»åŠ¡ä¼˜å…ˆçº§çŸ©é˜µ

### P0 - æ ¸å¿ƒåŠŸèƒ½ï¼ˆå¿…é¡»å®Œæˆï¼‰
- å“åº”å¼å¸ƒå±€ç³»ç»Ÿ
- CADæ™ºèƒ½ä½“åŠŸèƒ½æ•´åˆ
- åŸºç¡€UIç»„ä»¶åº“
- APIæ¥å£ä½“ç³»

### P1 - é‡è¦åŠŸèƒ½ï¼ˆåº”è¯¥å®Œæˆï¼‰
- æ¬¢è¿é¡µé¢ä¼˜åŒ–
- æ™ºèƒ½ä½“åˆ‡æ¢ç³»ç»Ÿ
- æ€§èƒ½ç›‘æ§
- é”™è¯¯å¤„ç†æœºåˆ¶

### P2 - å¢å¼ºåŠŸèƒ½ï¼ˆå¯ä»¥å®Œæˆï¼‰
- PWAæ”¯æŒ
- ç¦»çº¿åŠŸèƒ½
- é«˜çº§åŠ¨ç”»æ•ˆæœ
- å¤šè¯­è¨€æ”¯æŒ

## ğŸ”§ æ™ºèƒ½ä½“Aè¯¦ç»†ä»»åŠ¡åˆ†è§£

### Week 1: åŸºç¡€å“åº”å¼ç³»ç»Ÿå»ºè®¾

#### ä»»åŠ¡A1-1: æ–­ç‚¹ç³»ç»Ÿåˆ›å»º
**æ–‡ä»¶**: `lib/constants/breakpoints.ts`
**å·¥ä½œé‡**: 4å°æ—¶
**è¯¦ç»†æ­¥éª¤**:
```typescript
// 1. å®šä¹‰10ä¸ªå“åº”å¼æ–­ç‚¹
export const BREAKPOINTS = {
  xs: '320px',    // å°å±æ‰‹æœº (iPhone SE)
  sm: '375px',    // æ ‡å‡†æ‰‹æœº (iPhone 12/13)
  md: '414px',    // å¤§å±æ‰‹æœº (iPhone 12 Pro Max)
  lg: '768px',    // å¹³æ¿ç«–å± (iPad)
  xl: '1024px',   // å¹³æ¿æ¨ªå± (iPad Pro)
  '2xl': '1280px', // æ ‡å‡†æ¡Œé¢
  '3xl': '1440px', // å¤§å±æ¡Œé¢
  '4xl': '1920px', // å…¨é«˜æ¸…æ˜¾ç¤ºå™¨
  '5xl': '2560px', // 2Kæ˜¾ç¤ºå™¨
  '6xl': '3840px', // 4Kæ˜¾ç¤ºå™¨
} as const;

// 2. åˆ›å»ºæ–­ç‚¹å·¥å…·å‡½æ•°
export const getBreakpointValue = (breakpoint: keyof typeof BREAKPOINTS) => {
  return parseInt(BREAKPOINTS[breakpoint]);
};

// 3. åª’ä½“æŸ¥è¯¢åŠ©æ‰‹
export const mediaQueries = {
  xs: `(min-width: ${BREAKPOINTS.xs})`,
  sm: `(min-width: ${BREAKPOINTS.sm})`,
  md: `(min-width: ${BREAKPOINTS.md})`,
  lg: `(min-width: ${BREAKPOINTS.lg})`,
  xl: `(min-width: ${BREAKPOINTS.xl})`,
  '2xl': `(min-width: ${BREAKPOINTS['2xl']})`,
  '3xl': `(min-width: ${BREAKPOINTS['3xl']})`,
  '4xl': `(min-width: ${BREAKPOINTS['4xl']})`,
  '5xl': `(min-width: ${BREAKPOINTS['5xl']})`,
  '6xl': `(min-width: ${BREAKPOINTS['6xl']})`,
};
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] æ‰€æœ‰æ–­ç‚¹å€¼ç¬¦åˆè®¾è®¡è§„èŒƒ
- [ ] åª’ä½“æŸ¥è¯¢å‡½æ•°å·¥ä½œæ­£å¸¸
- [ ] TypeScriptç±»å‹å®šä¹‰å®Œæ•´
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–ç‡100%

#### ä»»åŠ¡A1-2: è®¾å¤‡æ£€æµ‹Hookå¼€å‘
**æ–‡ä»¶**: `hooks/use-device-detection.ts`
**å·¥ä½œé‡**: 8å°æ—¶
**è¯¦ç»†æ­¥éª¤**:
```typescript
interface DeviceInfo {
  // è®¾å¤‡ç±»å‹æ£€æµ‹
  deviceType: 'mobile' | 'tablet' | 'desktop' | 'tv';
  // è§¦æ‘¸æ”¯æŒ
  hasTouch: boolean;
  // å±å¹•åƒç´ æ¯”
  pixelRatio: number;
  // å±å¹•æ–¹å‘
  orientation: 'portrait' | 'landscape';
  // æ€§èƒ½çº§åˆ«è¯„ä¼°
  performanceLevel: 'high' | 'medium' | 'low';
  // ç½‘ç»œè¿æ¥é€Ÿåº¦
  connectionSpeed: 'slow-2g' | '2g' | '3g' | '4g' | '5g';
  // æ“ä½œç³»ç»Ÿ
  platform: 'ios' | 'android' | 'windows' | 'macos' | 'linux';
  // æµè§ˆå™¨ä¿¡æ¯
  browser: 'chrome' | 'safari' | 'firefox' | 'edge';
  // æ˜¯å¦æ”¯æŒWebGL
  hasWebGL: boolean;
  // å†…å­˜ä¿¡æ¯ï¼ˆå¦‚æœå¯ç”¨ï¼‰
  memory?: number;
}

export const useDeviceDetection = (): DeviceInfo => {
  const [deviceInfo, setDeviceInfo] = useState<DeviceInfo>({
    deviceType: 'desktop',
    hasTouch: false,
    pixelRatio: 1,
    orientation: 'landscape',
    performanceLevel: 'high',
    connectionSpeed: '4g',
    platform: 'windows',
    browser: 'chrome',
    hasWebGL: false,
  });

  useEffect(() => {
    const detectDevice = () => {
      // 1. æ£€æµ‹è®¾å¤‡ç±»å‹
      const deviceType = getDeviceType();
      
      // 2. æ£€æµ‹è§¦æ‘¸æ”¯æŒ
      const hasTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      
      // 3. è·å–åƒç´ æ¯”
      const pixelRatio = window.devicePixelRatio || 1;
      
      // 4. æ£€æµ‹å±å¹•æ–¹å‘
      const orientation = window.innerHeight > window.innerWidth ? 'portrait' : 'landscape';
      
      // 5. è¯„ä¼°æ€§èƒ½çº§åˆ«
      const performanceLevel = evaluatePerformance();
      
      // 6. æ£€æµ‹ç½‘ç»œé€Ÿåº¦
      const connectionSpeed = getConnectionSpeed();
      
      // 7. æ£€æµ‹å¹³å°å’Œæµè§ˆå™¨
      const { platform, browser } = getPlatformAndBrowser();
      
      // 8. æ£€æµ‹WebGLæ”¯æŒ
      const hasWebGL = checkWebGLSupport();
      
      // 9. è·å–å†…å­˜ä¿¡æ¯
      const memory = (navigator as any).deviceMemory;
      
      setDeviceInfo({
        deviceType,
        hasTouch,
        pixelRatio,
        orientation,
        performanceLevel,
        connectionSpeed,
        platform,
        browser,
        hasWebGL,
        memory,
      });
    };

    detectDevice();
    
    // ç›‘å¬çª—å£å¤§å°å˜åŒ–
    window.addEventListener('resize', detectDevice);
    window.addEventListener('orientationchange', detectDevice);
    
    return () => {
      window.removeEventListener('resize', detectDevice);
      window.removeEventListener('orientationchange', detectDevice);
    };
  }, []);

  return deviceInfo;
};

// è¾…åŠ©å‡½æ•°å®ç°
const getDeviceType = (): DeviceInfo['deviceType'] => {
  const userAgent = navigator.userAgent;
  const width = window.innerWidth;
  
  if (/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
    if (width < 768) return 'mobile';
    if (width < 1024) return 'tablet';
    return 'desktop';
  }
  
  if (width < 768) return 'mobile';
  if (width < 1024) return 'tablet';
  if (width > 1920) return 'tv';
  return 'desktop';
};

const evaluatePerformance = (): DeviceInfo['performanceLevel'] => {
  const memory = (navigator as any).deviceMemory || 4;
  const cores = navigator.hardwareConcurrency || 4;
  const connection = (navigator as any).connection;
  
  let score = 0;
  
  // å†…å­˜è¯„åˆ†
  if (memory >= 8) score += 3;
  else if (memory >= 4) score += 2;
  else score += 1;
  
  // CPUæ ¸å¿ƒæ•°è¯„åˆ†
  if (cores >= 8) score += 3;
  else if (cores >= 4) score += 2;
  else score += 1;
  
  // ç½‘ç»œè¯„åˆ†
  if (connection) {
    if (connection.effectiveType === '4g') score += 2;
    else if (connection.effectiveType === '3g') score += 1;
  } else {
    score += 2; // é»˜è®¤å‡è®¾è‰¯å¥½ç½‘ç»œ
  }
  
  if (score >= 7) return 'high';
  if (score >= 4) return 'medium';
  return 'low';
};
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] å‡†ç¡®æ£€æµ‹æ‰€æœ‰ä¸»æµè®¾å¤‡ç±»å‹
- [ ] æ€§èƒ½è¯„ä¼°ç®—æ³•ç»è¿‡æµ‹è¯•éªŒè¯
- [ ] æ”¯æŒå®æ—¶ç›‘å¬è®¾å¤‡çŠ¶æ€å˜åŒ–
- [ ] TypeScriptç±»å‹å®‰å…¨
- [ ] æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•é€šè¿‡

#### ä»»åŠ¡A1-3: å“åº”å¼å·¥å…·Hookå¼€å‘
**æ–‡ä»¶**: `hooks/use-responsive.ts`
**å·¥ä½œé‡**: 6å°æ—¶
```typescript
interface ResponsiveConfig {
  xs?: any;
  sm?: any;
  md?: any;
  lg?: any;
  xl?: any;
  '2xl'?: any;
  '3xl'?: any;
  '4xl'?: any;
  '5xl'?: any;
  '6xl'?: any;
}

interface ResponsiveState {
  // å½“å‰æ–­ç‚¹
  currentBreakpoint: keyof typeof BREAKPOINTS;
  // è®¾å¤‡ç±»åˆ«åˆ¤æ–­
  isMobile: boolean;
  isTablet: boolean;
  isDesktop: boolean;
  isTV: boolean;
  // æ–¹å‘åˆ¤æ–­
  isPortrait: boolean;
  isLandscape: boolean;
  // å°ºå¯¸ä¿¡æ¯
  width: number;
  height: number;
  // å“åº”å¼å€¼è·å–å‡½æ•°
  getValue: <T>(config: ResponsiveConfig) => T;
  // æ–­ç‚¹åŒ¹é…å‡½æ•°
  matches: (breakpoint: keyof typeof BREAKPOINTS) => boolean;
  // èŒƒå›´åŒ¹é…å‡½æ•°
  between: (min: keyof typeof BREAKPOINTS, max: keyof typeof BREAKPOINTS) => boolean;
}

export const useResponsive = (): ResponsiveState => {
  const [state, setState] = useState<Omit<ResponsiveState, 'getValue' | 'matches' | 'between'>>({
    currentBreakpoint: 'lg',
    isMobile: false,
    isTablet: false,
    isDesktop: true,
    isTV: false,
    isPortrait: false,
    isLandscape: true,
    width: 1920,
    height: 1080,
  });

  useEffect(() => {
    const updateState = () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      
      // ç¡®å®šå½“å‰æ–­ç‚¹
      const currentBreakpoint = getCurrentBreakpoint(width);
      
      // ç¡®å®šè®¾å¤‡ç±»åˆ«
      const isMobile = width < getBreakpointValue('lg');
      const isTablet = width >= getBreakpointValue('lg') && width < getBreakpointValue('xl');
      const isDesktop = width >= getBreakpointValue('xl') && width < getBreakpointValue('4xl');
      const isTV = width >= getBreakpointValue('4xl');
      
      // ç¡®å®šå±å¹•æ–¹å‘
      const isPortrait = height > width;
      const isLandscape = width >= height;
      
      setState({
        currentBreakpoint,
        isMobile,
        isTablet,
        isDesktop,
        isTV,
        isPortrait,
        isLandscape,
        width,
        height,
      });
    };

    updateState();
    
    window.addEventListener('resize', updateState);
    window.addEventListener('orientationchange', () => {
      setTimeout(updateState, 100); // å»¶è¿Ÿç¡®ä¿æ–¹å‘å˜åŒ–å®Œæˆ
    });
    
    return () => {
      window.removeEventListener('resize', updateState);
      window.removeEventListener('orientationchange', updateState);
    };
  }, []);

  const getValue = useCallback(<T>(config: ResponsiveConfig): T => {
    const breakpoints = Object.keys(BREAKPOINTS) as (keyof typeof BREAKPOINTS)[];
    const currentIndex = breakpoints.indexOf(state.currentBreakpoint);
    
    // ä»å½“å‰æ–­ç‚¹å‘ä¸‹æŸ¥æ‰¾æœ€è¿‘çš„é…ç½®å€¼
    for (let i = currentIndex; i >= 0; i--) {
      const breakpoint = breakpoints[i];
      if (config[breakpoint] !== undefined) {
        return config[breakpoint];
      }
    }
    
    // å¦‚æœæ²¡æ‰¾åˆ°ï¼Œè¿”å›æœ€å°æ–­ç‚¹çš„å€¼
    return config.xs;
  }, [state.currentBreakpoint]);

  const matches = useCallback((breakpoint: keyof typeof BREAKPOINTS): boolean => {
    return state.width >= getBreakpointValue(breakpoint);
  }, [state.width]);

  const between = useCallback((
    min: keyof typeof BREAKPOINTS, 
    max: keyof typeof BREAKPOINTS
  ): boolean => {
    return state.width >= getBreakpointValue(min) && state.width < getBreakpointValue(max);
  }, [state.width]);

  return {
    ...state,
    getValue,
    matches,
    between,
  };
};

// è¾…åŠ©å‡½æ•°
const getCurrentBreakpoint = (width: number): keyof typeof BREAKPOINTS => {
  const breakpoints = Object.entries(BREAKPOINTS)
    .map(([key, value]) => ({ key: key as keyof typeof BREAKPOINTS, value: parseInt(value) }))
    .sort((a, b) => b.value - a.value);
  
  for (const { key, value } of breakpoints) {
    if (width >= value) {
      return key;
    }
  }
  
  return 'xs';
};
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] å“åº”å¼å€¼è®¡ç®—å‡†ç¡®
- [ ] æ–­ç‚¹åŒ¹é…é€»è¾‘æ­£ç¡®
- [ ] æ€§èƒ½ä¼˜åŒ–ï¼ˆé˜²æŠ–å¤„ç†ï¼‰
- [ ] å†…å­˜æ³„æ¼æµ‹è¯•é€šè¿‡
- [ ] è¾¹ç•Œæ¡ä»¶æµ‹è¯•é€šè¿‡

### Week 2: æ ¸å¿ƒUIç»„ä»¶å¼€å‘

#### ä»»åŠ¡A2-1: Buttonç»„ä»¶å“åº”å¼æ”¹é€ 
**æ–‡ä»¶**: `components/ui/button.tsx`
**å·¥ä½œé‡**: 6å°æ—¶
```typescript
import { forwardRef } from 'react';
import { Slot } from '@radix-ui/react-slot';
import { cva, type VariantProps } from 'class-variance-authority';
import { cn } from '@/lib/utils';
import { useResponsive } from '@/hooks/use-responsive';

const buttonVariants = cva(
  // åŸºç¡€æ ·å¼
  'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50',
  {
    variants: {
      variant: {
        default: 'bg-primary text-primary-foreground shadow hover:bg-primary/90',
        destructive: 'bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90',
        outline: 'border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground',
        secondary: 'bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-primary underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-9 px-4 py-2',
        sm: 'h-8 rounded-md px-3 text-xs',
        lg: 'h-10 rounded-md px-8',
        xl: 'h-12 rounded-lg px-10 text-base',
        icon: 'h-9 w-9',
      },
      // å“åº”å¼è§¦æ‘¸ä¼˜åŒ–
      touchOptimized: {
        true: '',
        false: '',
      },
    },
    // å¤åˆå˜ä½“ - æ ¹æ®è®¾å¤‡ç±»å‹è°ƒæ•´
    compoundVariants: [
      {
        touchOptimized: true,
        size: 'default',
        class: 'h-11 px-6 py-3', // ç§»åŠ¨ç«¯å¢å¤§è§¦æ‘¸ç›®æ ‡
      },
      {
        touchOptimized: true,
        size: 'sm',
        class: 'h-10 px-4 py-2',
      },
      {
        touchOptimized: true,
        size: 'lg',
        class: 'h-12 px-8 py-3',
      },
      {
        touchOptimized: true,
        size: 'icon',
        class: 'h-11 w-11',
      },
    ],
    defaultVariants: {
      variant: 'default',
      size: 'default',
      touchOptimized: false,
    },
  }
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
  // å“åº”å¼å°ºå¯¸é…ç½®
  responsiveSize?: {
    xs?: VariantProps<typeof buttonVariants>['size'];
    sm?: VariantProps<typeof buttonVariants>['size'];
    md?: VariantProps<typeof buttonVariants>['size'];
    lg?: VariantProps<typeof buttonVariants>['size'];
    xl?: VariantProps<typeof buttonVariants>['size'];
  };
  // åŠ è½½çŠ¶æ€
  loading?: boolean;
  // å›¾æ ‡
  leftIcon?: React.ReactNode;
  rightIcon?: React.ReactNode;
}

const Button = forwardRef<HTMLButtonElement, ButtonProps>(
  ({ 
    className, 
    variant, 
    size, 
    asChild = false, 
    touchOptimized,
    responsiveSize,
    loading = false,
    leftIcon,
    rightIcon,
    children,
    disabled,
    ...props 
  }, ref) => {
    const { isMobile, isTablet, getValue } = useResponsive();
    
    // è‡ªåŠ¨æ£€æµ‹æ˜¯å¦éœ€è¦è§¦æ‘¸ä¼˜åŒ–
    const shouldOptimizeForTouch = touchOptimized ?? (isMobile || isTablet);
    
    // è·å–å“åº”å¼å°ºå¯¸
    const currentSize = responsiveSize ? getValue(responsiveSize) || size : size;
    
    const Comp = asChild ? Slot : 'button';
    
    return (
      <Comp
        className={cn(
          buttonVariants({ 
            variant, 
            size: currentSize, 
            touchOptimized: shouldOptimizeForTouch 
          }),
          // åŠ è½½çŠ¶æ€æ ·å¼
          loading && 'relative text-transparent pointer-events-none',
          className
        )}
        ref={ref}
        disabled={disabled || loading}
        // è§¦æ‘¸è®¾å¤‡ä¼˜åŒ–
        {...(shouldOptimizeForTouch && {
          'data-touch-optimized': 'true',
        })}
        {...props}
      >
        {loading && (
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="h-4 w-4 animate-spin rounded-full border-2 border-current border-r-transparent" />
          </div>
        )}
        
        {!loading && (
          <>
            {leftIcon && (
              <span className="mr-2 flex-shrink-0">
                {leftIcon}
              </span>
            )}
            {children}
            {rightIcon && (
              <span className="ml-2 flex-shrink-0">
                {rightIcon}
              </span>
            )}
          </>
        )}
      </Comp>
    );
  }
);

Button.displayName = 'Button';

export { Button, buttonVariants };
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] åœ¨æ‰€æœ‰æ–­ç‚¹ä¸‹æ˜¾ç¤ºæ­£ç¡®
- [ ] è§¦æ‘¸ç›®æ ‡æ»¡è¶³44pxæœ€å°è¦æ±‚
- [ ] åŠ è½½çŠ¶æ€åŠ¨ç”»æµç•…
- [ ] é”®ç›˜å¯¼èˆªå¯è®¿é—®
- [ ] å±å¹•é˜…è¯»å™¨å…¼å®¹

## ğŸ”§ æ™ºèƒ½ä½“Bè¯¦ç»†ä»»åŠ¡åˆ†è§£

### Week 1: æ™ºèƒ½ä½“ç³»ç»Ÿæ¶æ„

#### ä»»åŠ¡B1-1: æ™ºèƒ½ä½“æ³¨å†Œä¸­å¿ƒå¼€å‘
**æ–‡ä»¶**: `lib/agents/registry.ts`
**å·¥ä½œé‡**: 8å°æ—¶
**è¯¦ç»†æ­¥éª¤**:
```typescript
import { EventEmitter } from 'events';

export enum AgentStatus {
  ONLINE = 'online',
  OFFLINE = 'offline',
  BUSY = 'busy',
  MAINTENANCE = 'maintenance',
  ERROR = 'error',
}

export enum AgentCategory {
  GENERAL = 'general',
  TECHNICAL = 'technical',
  CREATIVE = 'creative',
  ANALYTICAL = 'analytical',
}

export interface AgentCapability {
  id: string;
  name: string;
  description: string;
  required: boolean;
  version: string;
}

export interface Agent {
  id: string;
  name: string;
  description: string;
  icon: string;
  route: string;
  category: AgentCategory;
  status: AgentStatus;
  version: string;
  capabilities: AgentCapability[];
  config: Record<string, any>;
  // æ€§èƒ½æŒ‡æ ‡
  metrics: {
    averageResponseTime: number;
    successRate: number;
    totalRequests: number;
    lastUsed: Date;
  };
  // å¥åº·æ£€æŸ¥
  healthCheck: {
    endpoint: string;
    interval: number;
    timeout: number;
  };
  // ä¾èµ–å…³ç³»
  dependencies: string[];
  // èµ„æºéœ€æ±‚
  resources: {
    memory: number;
    cpu: number;
    storage: number;
  };
}

export class AgentRegistry extends EventEmitter {
  private agents: Map<string, Agent> = new Map();
  private healthCheckIntervals: Map<string, NodeJS.Timeout> = new Map();
  
  constructor() {
    super();
    this.initializeHealthChecks();
  }

  // æ³¨å†Œæ™ºèƒ½ä½“
  register(agent: Agent): void {
    this.validateAgent(agent);
    
    const existingAgent = this.agents.get(agent.id);
    if (existingAgent && existingAgent.version !== agent.version) {
      this.emit('agentUpdated', { old: existingAgent, new: agent });
    }
    
    this.agents.set(agent.id, {
      ...agent,
      metrics: {
        averageResponseTime: 0,
        successRate: 100,
        totalRequests: 0,
        lastUsed: new Date(),
        ...agent.metrics,
      },
    });
    
    this.startHealthCheck(agent);
    this.emit('agentRegistered', agent);
  }

  // æ³¨é”€æ™ºèƒ½ä½“
  unregister(agentId: string): boolean {
    const agent = this.agents.get(agentId);
    if (!agent) return false;
    
    this.stopHealthCheck(agentId);
    this.agents.delete(agentId);
    this.emit('agentUnregistered', agent);
    return true;
  }

  // è·å–æ™ºèƒ½ä½“
  getAgent(id: string): Agent | undefined {
    return this.agents.get(id);
  }

  // è·å–æ‰€æœ‰æ™ºèƒ½ä½“
  getAllAgents(): Agent[] {
    return Array.from(this.agents.values());
  }

  // æŒ‰ç±»åˆ«è·å–æ™ºèƒ½ä½“
  getAgentsByCategory(category: AgentCategory): Agent[] {
    return this.getAllAgents().filter(agent => agent.category === category);
  }

  // æŒ‰çŠ¶æ€è·å–æ™ºèƒ½ä½“
  getAgentsByStatus(status: AgentStatus): Agent[] {
    return this.getAllAgents().filter(agent => agent.status === status);
  }

  // è·å–å¯ç”¨æ™ºèƒ½ä½“
  getAvailableAgents(): Agent[] {
    return this.getAgentsByStatus(AgentStatus.ONLINE);
  }

  // æŸ¥æ‰¾æœ€ä½³æ™ºèƒ½ä½“
  findBestAgent(requirements: {
    category?: AgentCategory;
    capabilities?: string[];
    minSuccessRate?: number;
    maxResponseTime?: number;
  }): Agent | null {
    let candidates = this.getAvailableAgents();
    
    // æŒ‰ç±»åˆ«è¿‡æ»¤
    if (requirements.category) {
      candidates = candidates.filter(agent => agent.category === requirements.category);
    }
    
    // æŒ‰èƒ½åŠ›è¿‡æ»¤
    if (requirements.capabilities) {
      candidates = candidates.filter(agent => 
        requirements.capabilities!.every(cap => 
          agent.capabilities.some(agentCap => agentCap.id === cap)
        )
      );
    }
    
    // æŒ‰æ€§èƒ½æŒ‡æ ‡è¿‡æ»¤
    candidates = candidates.filter(agent => {
      if (requirements.minSuccessRate && agent.metrics.successRate < requirements.minSuccessRate) {
        return false;
      }
      if (requirements.maxResponseTime && agent.metrics.averageResponseTime > requirements.maxResponseTime) {
        return false;
      }
      return true;
    });
    
    if (candidates.length === 0) return null;
    
    // æŒ‰ç»¼åˆå¾—åˆ†æ’åº
    candidates.sort((a, b) => {
      const scoreA = this.calculateAgentScore(a);
      const scoreB = this.calculateAgentScore(b);
      return scoreB - scoreA;
    });
    
    return candidates[0];
  }

  // æ›´æ–°æ™ºèƒ½ä½“çŠ¶æ€
  updateAgentStatus(agentId: string, status: AgentStatus): boolean {
    const agent = this.agents.get(agentId);
    if (!agent) return false;
    
    const oldStatus = agent.status;
    agent.status = status;
    
    this.emit('agentStatusChanged', { agent, oldStatus, newStatus: status });
    return true;
  }

  // æ›´æ–°æ™ºèƒ½ä½“æŒ‡æ ‡
  updateAgentMetrics(
    agentId: string, 
    metrics: Partial<Agent['metrics']>
  ): boolean {
    const agent = this.agents.get(agentId);
    if (!agent) return false;
    
    agent.metrics = { ...agent.metrics, ...metrics };
    this.emit('agentMetricsUpdated', { agent, metrics });
    return true;
  }

  // è®°å½•æ™ºèƒ½ä½“ä½¿ç”¨
  recordUsage(agentId: string, responseTime: number, success: boolean): void {
    const agent = this.agents.get(agentId);
    if (!agent) return;
    
    const { metrics } = agent;
    const newTotal = metrics.totalRequests + 1;
    
    // æ›´æ–°å¹³å‡å“åº”æ—¶é—´
    metrics.averageResponseTime = 
      (metrics.averageResponseTime * metrics.totalRequests + responseTime) / newTotal;
    
    // æ›´æ–°æˆåŠŸç‡
    const successCount = Math.round(metrics.successRate * metrics.totalRequests / 100);
    const newSuccessCount = successCount + (success ? 1 : 0);
    metrics.successRate = (newSuccessCount / newTotal) * 100;
    
    metrics.totalRequests = newTotal;
    metrics.lastUsed = new Date();
    
    this.emit('agentUsed', { agent, responseTime, success });
  }

  // éªŒè¯æ™ºèƒ½ä½“é…ç½®
  private validateAgent(agent: Agent): void {
    if (!agent.id || !agent.name || !agent.route) {
      throw new Error('æ™ºèƒ½ä½“å¿…é¡»æœ‰idã€nameå’Œroute');
    }
    
    if (!Object.values(AgentCategory).includes(agent.category)) {
      throw new Error('æ— æ•ˆçš„æ™ºèƒ½ä½“ç±»åˆ«');
    }
    
    if (!Object.values(AgentStatus).includes(agent.status)) {
      throw new Error('æ— æ•ˆçš„æ™ºèƒ½ä½“çŠ¶æ€');
    }
    
    // éªŒè¯ä¾èµ–å…³ç³»
    for (const depId of agent.dependencies || []) {
      if (!this.agents.has(depId)) {
        console.warn(`æ™ºèƒ½ä½“ ${agent.id} ä¾èµ–çš„æ™ºèƒ½ä½“ ${depId} æœªæ‰¾åˆ°`);
      }
    }
  }

  // è®¡ç®—æ™ºèƒ½ä½“å¾—åˆ†
  private calculateAgentScore(agent: Agent): number {
    const { metrics } = agent;
    let score = 0;
    
    // æˆåŠŸç‡æƒé‡ 50%
    score += (metrics.successRate / 100) * 50;
    
    // å“åº”æ—¶é—´æƒé‡ 30% (åå‘åˆ†æ•°)
    const maxResponseTime = 10000; // 10ç§’
    const responseScore = Math.max(0, (maxResponseTime - metrics.averageResponseTime) / maxResponseTime);
    score += responseScore * 30;
    
    // ä½¿ç”¨é¢‘ç‡æƒé‡ 20%
    const usageScore = Math.min(100, metrics.totalRequests / 100);
    score += usageScore * 20;
    
    return score;
  }

  // å¥åº·æ£€æŸ¥
  private initializeHealthChecks(): void {
    // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡æ‰€æœ‰æ™ºèƒ½ä½“çš„å¥åº·çŠ¶æ€
    setInterval(() => {
      this.getAllAgents().forEach(agent => {
        if (agent.status === AgentStatus.ONLINE) {
          this.performHealthCheck(agent);
        }
      });
    }, 60000); // 1åˆ†é’Ÿ
  }

  private startHealthCheck(agent: Agent): void {
    if (!agent.healthCheck?.endpoint) return;
    
    this.stopHealthCheck(agent.id);
    
    const interval = setInterval(() => {
      this.performHealthCheck(agent);
    }, agent.healthCheck.interval || 30000);
    
    this.healthCheckIntervals.set(agent.id, interval);
  }

  private stopHealthCheck(agentId: string): void {
    const interval = this.healthCheckIntervals.get(agentId);
    if (interval) {
      clearInterval(interval);
      this.healthCheckIntervals.delete(agentId);
    }
  }

  private async performHealthCheck(agent: Agent): Promise<void> {
    if (!agent.healthCheck?.endpoint) return;
    
    try {
      const startTime = Date.now();
      const response = await fetch(agent.healthCheck.endpoint, {
        method: 'GET',
        timeout: agent.healthCheck.timeout || 5000,
      });
      
      const responseTime = Date.now() - startTime;
      
      if (response.ok) {
        if (agent.status !== AgentStatus.ONLINE) {
          this.updateAgentStatus(agent.id, AgentStatus.ONLINE);
        }
        this.recordUsage(agent.id, responseTime, true);
      } else {
        throw new Error(`å¥åº·æ£€æŸ¥å¤±è´¥: ${response.status}`);
      }
    } catch (error) {
      console.error(`æ™ºèƒ½ä½“ ${agent.id} å¥åº·æ£€æŸ¥å¤±è´¥:`, error);
      this.updateAgentStatus(agent.id, AgentStatus.ERROR);
      this.recordUsage(agent.id, 0, false);
    }
  }

  // å¯¼å‡º/å¯¼å…¥é…ç½®
  exportConfig(): string {
    const config = {
      agents: this.getAllAgents().map(agent => ({
        ...agent,
        metrics: undefined, // ä¸å¯¼å‡ºè¿è¡Œæ—¶æŒ‡æ ‡
      })),
      timestamp: new Date().toISOString(),
    };
    return JSON.stringify(config, null, 2);
  }

  importConfig(configJson: string): void {
    try {
      const config = JSON.parse(configJson);
      if (config.agents && Array.isArray(config.agents)) {
        config.agents.forEach((agent: Agent) => {
          this.register(agent);
        });
        this.emit('configImported', config);
      }
    } catch (error) {
      throw new Error(`é…ç½®å¯¼å…¥å¤±è´¥: ${error.message}`);
    }
  }

  // æ¸…ç†èµ„æº
  destroy(): void {
    // åœæ­¢æ‰€æœ‰å¥åº·æ£€æŸ¥
    this.healthCheckIntervals.forEach(interval => clearInterval(interval));
    this.healthCheckIntervals.clear();
    
    // æ¸…ç©ºæ™ºèƒ½ä½“
    this.agents.clear();
    
    // ç§»é™¤æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨
    this.removeAllListeners();
  }
}

// åˆ›å»ºå…¨å±€å®ä¾‹
export const agentRegistry = new AgentRegistry();

// æ™ºèƒ½ä½“å·¥å‚å‡½æ•°
export const createAgent = (config: Partial<Agent> & Pick<Agent, 'id' | 'name' | 'route'>): Agent => {
  return {
    description: '',
    icon: 'ğŸ¤–',
    category: AgentCategory.GENERAL,
    status: AgentStatus.ONLINE,
    version: '1.0.0',
    capabilities: [],
    config: {},
    metrics: {
      averageResponseTime: 0,
      successRate: 100,
      totalRequests: 0,
      lastUsed: new Date(),
    },
    healthCheck: {
      endpoint: `/api/health/${config.id}`,
      interval: 30000,
      timeout: 5000,
    },
    dependencies: [],
    resources: {
      memory: 512,
      cpu: 1,
      storage: 1024,
    },
    ...config,
  };
};
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] æ™ºèƒ½ä½“æ³¨å†Œå’Œæ³¨é”€åŠŸèƒ½æ­£å¸¸
- [ ] å¥åº·æ£€æŸ¥æœºåˆ¶å·¥ä½œç¨³å®š
- [ ] æ€§èƒ½æŒ‡æ ‡è®¡ç®—å‡†ç¡®
- [ ] äº‹ä»¶ç³»ç»Ÿå·¥ä½œæ­£å¸¸
- [ ] å†…å­˜ç®¡ç†æ— æ³„æ¼
- [ ] å¹¶å‘å®‰å…¨æµ‹è¯•é€šè¿‡

## ğŸ“‹ è´¨é‡ä¿è¯å’ŒéªŒæ”¶æ£€æŸ¥æ¸…å•

### æ™ºèƒ½ä½“Aè´¨é‡æ£€æŸ¥æ¸…å•
```markdown
# æ™ºèƒ½ä½“Aæ¯æ—¥è´¨é‡æ£€æŸ¥æ¸…å•

## å“åº”å¼è®¾è®¡æ£€æŸ¥
- [ ] 320px - 3840px æ‰€æœ‰æ–­ç‚¹æµ‹è¯•é€šè¿‡
- [ ] è§¦æ‘¸è®¾å¤‡æœ€å°44pxè§¦æ‘¸ç›®æ ‡
- [ ] æ¨ªç«–å±åˆ‡æ¢æµç•…
- [ ] é«˜DPIå±å¹•æ˜¾ç¤ºæ¸…æ™°

## æ€§èƒ½æŒ‡æ ‡æ£€æŸ¥
- [ ] é¦–å±åŠ è½½æ—¶é—´ < 1.5s
- [ ] åŠ¨ç”»å¸§ç‡ â‰¥ 60fps
- [ ] å†…å­˜ä½¿ç”¨ç¨³å®š
- [ ] åŒ…ä½“ç§¯ < 500KB (gzipped)

## æ— éšœç¢è®¿é—®æ£€æŸ¥
- [ ] é”®ç›˜å¯¼èˆªå®Œæ•´
- [ ] å±å¹•é˜…è¯»å™¨å…¼å®¹
- [ ] å¯¹æ¯”åº¦æ¯”ä¾‹ â‰¥ 4.5:1
- [ ] ARIAæ ‡ç­¾å®Œæ•´

## ä»£ç è´¨é‡æ£€æŸ¥
- [ ] TypeScriptç¼–è¯‘æ— é”™è¯¯
- [ ] ESLintæ— è­¦å‘Š
- [ ] æµ‹è¯•è¦†ç›–ç‡ â‰¥ 80%
- [ ] ç»„ä»¶æ–‡æ¡£å®Œæ•´
```

### æ™ºèƒ½ä½“Bè´¨é‡æ£€æŸ¥æ¸…å•
```markdown
# æ™ºèƒ½ä½“Bæ¯æ—¥è´¨é‡æ£€æŸ¥æ¸…å•

## APIåŠŸèƒ½æ£€æŸ¥
- [ ] æ‰€æœ‰æ¥å£å“åº”æ­£å¸¸
- [ ] é”™è¯¯å¤„ç†å®Œå–„
- [ ] æ•°æ®éªŒè¯ä¸¥æ ¼
- [ ] æƒé™æ§åˆ¶æ­£ç¡®

## CADåŠŸèƒ½æ£€æŸ¥
- [ ] .dwg/.dxf/.step/.igesæ–‡ä»¶è§£ææ­£å¸¸
- [ ] AIåˆ†æç»“æœå‡†ç¡®
- [ ] æ–‡ä»¶ä¸Šä¼ è¿›åº¦æ˜¾ç¤º
- [ ] å†å²è®°å½•ä¿å­˜æ­£ç¡®

## æ€§èƒ½æŒ‡æ ‡æ£€æŸ¥
- [ ] APIå“åº”æ—¶é—´ < 500ms
- [ ] æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
- [ ] æ–‡ä»¶å¤„ç†å¼‚æ­¥åŒ–
- [ ] å†…å­˜ä½¿ç”¨ç›‘æ§

## å®‰å…¨æ€§æ£€æŸ¥
- [ ] è¾“å…¥éªŒè¯å®Œæ•´
- [ ] SQLæ³¨å…¥é˜²æŠ¤
- [ ] æ–‡ä»¶ä¸Šä¼ å®‰å…¨
- [ ] æ•æ„Ÿä¿¡æ¯åŠ å¯†
```

## ğŸš¨ é£é™©æ§åˆ¶å’Œé—®é¢˜å¤„ç†

### å¸¸è§é£é™©å’Œé¢„é˜²æªæ–½
```markdown
# å¼€å‘é£é™©æ§åˆ¶çŸ©é˜µ

## é«˜é£é™©é—®é¢˜
1. **æ–‡ä»¶å†²çª**
   - é£é™©ï¼šåŒæ—¶ä¿®æ”¹å…±äº«æ–‡ä»¶å¯¼è‡´ä»£ç å†²çª
   - é¢„é˜²ï¼šä¸¥æ ¼éµå®ˆæ–‡ä»¶åˆ†å·¥ï¼Œä½¿ç”¨Gitä¿æŠ¤åˆ†æ”¯
   - åº”æ€¥ï¼šç«‹å³åœæ­¢å¼€å‘ï¼Œæ‰‹åŠ¨åˆå¹¶å†²çªåç»§ç»­

2. **æ¥å£ä¸åŒ¹é…**
   - é£é™©ï¼šæ™ºèƒ½ä½“Aå’ŒBçš„æ¥å£å®šä¹‰ä¸ä¸€è‡´
   - é¢„é˜²ï¼šå…±äº«TypeScriptç±»å‹å®šä¹‰ï¼Œè‡ªåŠ¨åŒ–ç±»å‹æ£€æŸ¥
   - åº”æ€¥ï¼šæ›´æ–°æ¥å£å¥‘çº¦ï¼Œé‡æ–°æµ‹è¯•é›†æˆ

3. **æ€§èƒ½é€€åŒ–**
   - é£é™©ï¼šæ–°åŠŸèƒ½å¯¼è‡´ç³»ç»Ÿæ€§èƒ½ä¸‹é™
   - é¢„é˜²ï¼šæ¯æ—¥æ€§èƒ½ç›‘æ§ï¼Œè‡ªåŠ¨åŒ–æ€§èƒ½æµ‹è¯•
   - åº”æ€¥ï¼šæ€§èƒ½å‰–æå®šä½é—®é¢˜ï¼Œå›æ»šé—®é¢˜ä»£ç 

## ä¸­ç­‰é£é™©é—®é¢˜
1. **ä¾èµ–å†²çª**
   - é£é™©ï¼šä¸¤ä¸ªæ™ºèƒ½ä½“å®‰è£…å†²çªçš„åŒ…ç‰ˆæœ¬
   - é¢„é˜²ï¼šé›†ä¸­ç®¡ç†package.jsonï¼Œç‰ˆæœ¬é”å®š
   - åº”æ€¥ï¼šä½¿ç”¨yarn resolutionsè§£å†³å†²çª

2. **æµ‹è¯•è¦†ç›–ä¸è¶³**
   - é£é™©ï¼šåŠŸèƒ½æµ‹è¯•ä¸å……åˆ†å¯¼è‡´ç”Ÿäº§é—®é¢˜
   - é¢„é˜²ï¼šå¼ºåˆ¶æµ‹è¯•è¦†ç›–ç‡è¦æ±‚ï¼Œè‡ªåŠ¨åŒ–æµ‹è¯•æµæ°´çº¿
   - åº”æ€¥ï¼šç´§æ€¥è¡¥å……æµ‹è¯•ç”¨ä¾‹

## ä½é£é™©é—®é¢˜
1. **ä»£ç é£æ ¼ä¸ä¸€è‡´**
   - é£é™©ï¼šå½±å“ä»£ç å¯ç»´æŠ¤æ€§
   - é¢„é˜²ï¼šESLint+Prettierè‡ªåŠ¨æ ¼å¼åŒ–
   - åº”æ€¥ï¼šç»Ÿä¸€æ ¼å¼åŒ–æ‰€æœ‰ä»£ç 

2. **æ–‡æ¡£ä¸å®Œæ•´**
   - é£é™©ï¼šå½±å“åç»­ç»´æŠ¤
   - é¢„é˜²ï¼šå¼€å‘è¿‡ç¨‹ä¸­åŒæ­¥æ›´æ–°æ–‡æ¡£
   - åº”æ€¥ï¼šè¡¥å……å…³é”®åŠŸèƒ½æ–‡æ¡£
```

### åº”æ€¥å¤„ç†æµç¨‹
```typescript
interface EmergencyProcedure {
  id: string;
  title: string;
  priority: 'critical' | 'high' | 'medium' | 'low';
  steps: string[];
  rollbackPlan: string[];
  contactList: string[];
  maxResolutionTime: number; // åˆ†é’Ÿ
}

const emergencyProcedures: EmergencyProcedure[] = [
  {
    id: 'code-conflict',
    title: 'ä»£ç å†²çªç´§æ€¥å¤„ç†',
    priority: 'critical',
    steps: [
      '1. ç«‹å³åœæ­¢æ‰€æœ‰å¼€å‘å·¥ä½œ',
      '2. å¤‡ä»½å½“å‰å·¥ä½œåˆ†æ”¯',
      '3. åˆ›å»ºå†²çªè§£å†³åˆ†æ”¯',
      '4. æ‰‹åŠ¨åˆå¹¶å†²çªä»£ç ',
      '5. è¿è¡Œå®Œæ•´æµ‹è¯•å¥—ä»¶',
      '6. ä¸¤ä¸ªæ™ºèƒ½ä½“éªŒæ”¶ç¡®è®¤',
      '7. åˆå¹¶åˆ°ä¸»åˆ†æ”¯',
    ],
    rollbackPlan: [
      '1. å›æ»šåˆ°æœ€åç¨³å®šç‰ˆæœ¬',
      '2. é‡æ–°åŒæ­¥å·¥ä½œè¿›åº¦',
      '3. åˆ†æå†²çªåŸå› ',
      '4. æ›´æ–°åä½œè§„èŒƒ',
    ],
    contactList: ['æ™ºèƒ½ä½“A', 'æ™ºèƒ½ä½“B', 'é¡¹ç›®è´Ÿè´£äºº'],
    maxResolutionTime: 60,
  },
];
```

è¿™ä¸ªè¯¦ç»†çš„å¼€å‘ä»»åŠ¡åˆ†è§£æ–‡æ¡£ç¡®ä¿äº†ï¼š

1. **ä»»åŠ¡ç²’åº¦ç»†åŒ–**ï¼šæ¯ä¸ªä»»åŠ¡éƒ½æœ‰å…·ä½“çš„å®æ–½æ­¥éª¤ã€ä»£ç ç¤ºä¾‹å’ŒéªŒæ”¶æ ‡å‡†
2. **è´¨é‡æ ‡å‡†æ˜ç¡®**ï¼šæ¯ä¸ªåŠŸèƒ½éƒ½æœ‰è¯¦ç»†çš„æµ‹è¯•è¦æ±‚å’Œæ€§èƒ½æŒ‡æ ‡
3. **é£é™©æ§åˆ¶å®Œå–„**ï¼šé¢„è®¾äº†å¸¸è§é—®é¢˜çš„é¢„é˜²å’Œåº”æ€¥å¤„ç†æªæ–½
4. **åä½œæœºåˆ¶æ¸…æ™°**ï¼šæ˜ç¡®äº†ä¸¤ä¸ªæ™ºèƒ½ä½“çš„åä½œæ–¹å¼å’Œå†²çªè§£å†³æµç¨‹

æ¥ä¸‹æ¥æˆ‘å°†åˆ›å»ºæ›´å¤šæ”¯æ’‘æ–‡æ¡£æ¥ç¡®ä¿å¼€å‘è´¨é‡. 