# ZK-Agent æ™ºèƒ½ä½“é”™è¯¯å¤„ç†ä¼˜åŒ–æ–¹æ¡ˆ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–¹æ¡ˆæ—¨åœ¨å»ºç«‹ZK-Agentå¹³å°ç»Ÿä¸€çš„æ™ºèƒ½ä½“é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œæå‡ç³»ç»Ÿç¨³å®šæ€§å’Œç”¨æˆ·ä½“éªŒã€‚

## ğŸ¯ ä¼˜åŒ–ç›®æ ‡

### 1. ç»Ÿä¸€é”™è¯¯åˆ†ç±»ä½“ç³»

-   å»ºç«‹æ ‡å‡†åŒ–çš„é”™è¯¯ç±»å‹å®šä¹‰
-   å®ç°é”™è¯¯ç ç»Ÿä¸€ç®¡ç†
-   æä¾›å¤šè¯­è¨€é”™è¯¯ä¿¡æ¯æ”¯æŒ

### 2. æ™ºèƒ½ä½“ä¸“é¡¹ä¼˜åŒ–

-   CADåˆ†ææ™ºèƒ½ä½“å®¹é”™æœºåˆ¶
-   æµ·æŠ¥ç”Ÿæˆæ™ºèƒ½ä½“é‡è¯•ç­–ç•¥
-   å¯¹è¯æ™ºèƒ½ä½“ä¸Šä¸‹æ–‡æ¢å¤

### 3. ç³»ç»Ÿçº§é”™è¯¯å¤„ç†

-   æ™ºèƒ½ä½“é—´é€šä¿¡å¼‚å¸¸å¤„ç†
-   èµ„æºè€—å°½æ—¶çš„è´Ÿè½½å‡è¡¡
-   æœåŠ¡é™çº§å’Œç†”æ–­æœºåˆ¶

## ğŸ”§ é”™è¯¯åˆ†ç±»ä½“ç³»

### A. ä¸šåŠ¡é”™è¯¯ç±»å‹

``` typescript
enum AgentErrorType {
  // CADåˆ†æé”™è¯¯
  CAD_FILE_PARSE_ERROR = 'CAD_FILE_PARSE_ERROR',
  CAD_FORMAT_UNSUPPORTED = 'CAD_FORMAT_UNSUPPORTED',
  CAD_FILE_CORRUPTED = 'CAD_FILE_CORRUPTED',
  CAD_ANALYSIS_TIMEOUT = 'CAD_ANALYSIS_TIMEOUT',
  
  // æµ·æŠ¥ç”Ÿæˆé”™è¯¯
  POSTER_GENERATION_FAILED = 'POSTER_GENERATION_FAILED',
  POSTER_TEMPLATE_ERROR = 'POSTER_TEMPLATE_ERROR',
  POSTER_RESOURCE_LIMIT = 'POSTER_RESOURCE_LIMIT',
  POSTER_TIMEOUT = 'POSTER_TIMEOUT',
  
  // å¯¹è¯æ™ºèƒ½ä½“é”™è¯¯
  CHAT_CONTEXT_LOST = 'CHAT_CONTEXT_LOST',
  CHAT_API_ERROR = 'CHAT_API_ERROR',
  CHAT_RATE_LIMIT = 'CHAT_RATE_LIMIT',
  CHAT_MODEL_UNAVAILABLE = 'CHAT_MODEL_UNAVAILABLE',
  
  // ç³»ç»Ÿçº§é”™è¯¯
  AGENT_COMMUNICATION_ERROR = 'AGENT_COMMUNICATION_ERROR',
  RESOURCE_EXHAUSTED = 'RESOURCE_EXHAUSTED',
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  AUTHENTICATION_ERROR = 'AUTHENTICATION_ERROR'
}
```

### B. é”™è¯¯ä¸¥é‡çº§åˆ«

``` typescript
enum ErrorSeverity {
  LOW = 'low',        // å¯å¿½ç•¥çš„è­¦å‘Š
  MEDIUM = 'medium',  // å½±å“åŠŸèƒ½ä½†å¯æ¢å¤
  HIGH = 'high',      // ä¸¥é‡å½±å“ç”¨æˆ·ä½“éªŒ
  CRITICAL = 'critical' // ç³»ç»Ÿçº§æ•…éšœ
}
```

## ğŸ¤– CADåˆ†ææ™ºèƒ½ä½“ä¼˜åŒ–

### 1. æ–‡ä»¶è§£æå®¹é”™æœºåˆ¶

``` typescript
class CADAnalysisAgent {
  async analyzeCADFile(file: File): Promise<CADAnalysisResult> {
    try {
      // ä¸»è¦è§£æé€»è¾‘
      return await this.primaryParser.parse(file);
    } catch (error) {
      if (error instanceof CADParseError) {
        // å°è¯•å¤‡ç”¨è§£æå™¨
        try {
          return await this.fallbackParser.parse(file);
        } catch (fallbackError) {
          // æä¾›åŸºç¡€ä¿¡æ¯
          return this.generateBasicInfo(file);
        }
      }
      throw error;
    }
  }
  
  private async generateBasicInfo(file: File): Promise<CADAnalysisResult> {
    return {
      fileName: file.name,
      fileSize: file.size,
      format: this.detectFormat(file),
      status: 'partial_analysis',
      message: 'æ–‡ä»¶è§£æé‡åˆ°é—®é¢˜ï¼Œå·²æä¾›åŸºç¡€ä¿¡æ¯'
    };
  }
}
```

### 2. åˆ†æè¶…æ—¶å¤„ç†

``` typescript
class CADTimeoutHandler {
  async analyzeWithTimeout(file: File, timeout: number = 30000): Promise<CADAnalysisResult> {
    const timeoutPromise = new Promise<never>((_, reject) => {
      setTimeout(() => reject(new CADAnalysisTimeout('åˆ†æè¶…æ—¶')), timeout);
    });
    
    try {
      return await Promise.race([
        this.cadAgent.analyzeCADFile(file),
        timeoutPromise
      ]);
    } catch (error) {
      if (error instanceof CADAnalysisTimeout) {
        // è¿”å›å¿«é€Ÿåˆ†æç»“æœ
        return await this.quickAnalysis(file);
      }
      throw error;
    }
  }
}
```

## ğŸ¨ æµ·æŠ¥ç”Ÿæˆæ™ºèƒ½ä½“ä¼˜åŒ–

### 1. é‡è¯•æœºåˆ¶

``` typescript
class PosterGenerationAgent {
  async generatePoster(config: PosterConfig): Promise<PosterResult> {
    const maxRetries = 3;
    let lastError: Error;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await this.attemptGeneration(config, attempt);
      } catch (error) {
        lastError = error;
        
        if (error instanceof PosterResourceLimit) {
          // ç­‰å¾…èµ„æºé‡Šæ”¾
          await this.waitForResources(attempt * 1000);
        } else if (error instanceof PosterTemplateError) {
          // å°è¯•å¤‡ç”¨æ¨¡æ¿
          config = this.useFallbackTemplate(config);
        }
        
        if (attempt === maxRetries) {
          throw new PosterGenerationFailed(
            `æµ·æŠ¥ç”Ÿæˆå¤±è´¥ï¼Œå·²é‡è¯•${maxRetries}æ¬¡`,
            lastError
          );
        }
      }
    }
  }
  
  private async attemptGeneration(config: PosterConfig, attempt: number): Promise<PosterResult> {
    // æ ¹æ®é‡è¯•æ¬¡æ•°è°ƒæ•´è´¨é‡è®¾ç½®
    const adjustedConfig = this.adjustQualityForRetry(config, attempt);
    return await this.coreGeneration(adjustedConfig);
  }
}
```

### 2. èµ„æºç›‘æ§å’Œé™çº§

``` typescript
class PosterResourceManager {
  async checkResourceAvailability(): Promise<ResourceStatus> {
    const memoryUsage = await this.getMemoryUsage();
    const cpuUsage = await this.getCPUUsage();
    
    if (memoryUsage > 0.9 || cpuUsage > 0.9) {
      return ResourceStatus.CRITICAL;
    } else if (memoryUsage > 0.7 || cpuUsage > 0.7) {
      return ResourceStatus.HIGH;
    }
    
    return ResourceStatus.NORMAL;
  }
  
  async generateWithResourceCheck(config: PosterConfig): Promise<PosterResult> {
    const resourceStatus = await this.checkResourceAvailability();
    
    switch (resourceStatus) {
      case ResourceStatus.CRITICAL:
        throw new PosterResourceLimit('ç³»ç»Ÿèµ„æºä¸è¶³ï¼Œè¯·ç¨åé‡è¯•');
      case ResourceStatus.HIGH:
        // é™ä½è´¨é‡è®¾ç½®
        config = this.reducedQualityConfig(config);
        break;
      default:
        // æ­£å¸¸å¤„ç†
        break;
    }
    
    return await this.posterAgent.generatePoster(config);
  }
}
```

## ğŸ’¬ å¯¹è¯æ™ºèƒ½ä½“ä¼˜åŒ–

### 1. ä¸Šä¸‹æ–‡æ¢å¤æœºåˆ¶

``` typescript
class ChatContextManager {
  async recoverContext(chatId: string): Promise<ChatContext> {
    try {
      // å°è¯•ä»ç¼“å­˜æ¢å¤
      const cachedContext = await this.cache.get(chatId);
      if (cachedContext) {
        return cachedContext;
      }
      
      // ä»æ•°æ®åº“æ¢å¤
      const dbContext = await this.database.getChatContext(chatId);
      if (dbContext) {
        await this.cache.set(chatId, dbContext);
        return dbContext;
      }
      
      // åˆ›å»ºæ–°ä¸Šä¸‹æ–‡
      return this.createNewContext(chatId);
    } catch (error) {
      // ä¸Šä¸‹æ–‡æ¢å¤å¤±è´¥ï¼Œåˆ›å»ºä¸´æ—¶ä¸Šä¸‹æ–‡
      return this.createTemporaryContext(chatId);
    }
  }
  
  private createTemporaryContext(chatId: string): ChatContext {
    return {
      chatId,
      messages: [],
      isTemporary: true,
      warningMessage: 'å¯¹è¯ä¸Šä¸‹æ–‡å·²é‡ç½®ï¼Œä¹‹å‰çš„å¯¹è¯è®°å½•å¯èƒ½ä¸¢å¤±'
    };
  }
}
```

### 2. APIè°ƒç”¨å®¹é”™

``` typescript
class ChatAPIHandler {
  async sendMessage(message: string, context: ChatContext): Promise<ChatResponse> {
    const maxRetries = 3;
    let lastError: Error;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await this.callChatAPI(message, context);
      } catch (error) {
        lastError = error;
        
        if (error instanceof ChatRateLimit) {
          // æŒ‡æ•°é€€é¿
          await this.delay(Math.pow(2, attempt) * 1000);
        } else if (error instanceof ChatModelUnavailable) {
          // åˆ‡æ¢åˆ°å¤‡ç”¨æ¨¡å‹
          context = this.switchToFallbackModel(context);
        } else if (error instanceof ChatAPIError) {
          // APIé”™è¯¯ï¼Œç›´æ¥é‡è¯•
          await this.delay(1000);
        } else {
          // å…¶ä»–é”™è¯¯ï¼Œä¸é‡è¯•
          throw error;
        }
      }
    }
    
    throw new ChatServiceUnavailable(
      'å¯¹è¯æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•',
      lastError
    );
  }
}
```

## ğŸ”„ æ™ºèƒ½ä½“é—´é€šä¿¡ä¼˜åŒ–

### 1. äº‹ä»¶æ€»çº¿å®¹é”™

``` typescript
class AgentEventBus {
  async publishEvent(event: AgentEvent): Promise<void> {
    try {
      await this.eventBus.publish(event);
    } catch (error) {
      // è®°å½•å¤±è´¥äº‹ä»¶
      await this.logFailedEvent(event, error);
      
      // å°è¯•ç›´æ¥é€šçŸ¥
      await this.directNotify(event);
    }
  }
  
  private async directNotify(event: AgentEvent): Promise<void> {
    const targetAgents = this.getTargetAgents(event);
    
    for (const agent of targetAgents) {
      try {
        await agent.handleEvent(event);
      } catch (error) {
        console.error(`Agent ${agent.id} failed to handle event:`, error);
      }
    }
  }
}
```

### 2. æœåŠ¡ç†”æ–­æœºåˆ¶

``` typescript
class AgentCircuitBreaker {
  private failureCount = 0;
  private lastFailureTime = 0;
  private state: 'CLOSED' | 'OPEN' | 'HALF_OPEN' = 'CLOSED';
  
  async callAgent(agentId: string, request: AgentRequest): Promise<AgentResponse> {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'HALF_OPEN';
      } else {
        throw new ServiceUnavailable(`æ™ºèƒ½ä½“ ${agentId} æš‚æ—¶ä¸å¯ç”¨`);
      }
    }
    
    try {
      const response = await this.agent.call(request);
      this.onSuccess();
      return response;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private onSuccess(): void {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }
  
  private onFailure(): void {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.threshold) {
      this.state = 'OPEN';
    }
  }
}
```

## ğŸ“Š é”™è¯¯ç›‘æ§å’ŒæŠ¥å‘Š

### 1. é”™è¯¯æ”¶é›†å™¨

``` typescript
class AgentErrorCollector {
  async reportError(error: AgentError): Promise<void> {
    const errorReport = {
      id: generateId(),
      timestamp: new Date(),
      agentType: error.agentType,
      errorType: error.type,
      severity: error.severity,
      message: error.message,
      stack: error.stack,
      context: error.context,
      userAgent: error.userAgent,
      sessionId: error.sessionId
    };
    
    // å­˜å‚¨é”™è¯¯æŠ¥å‘Š
    await this.storage.save(errorReport);
    
    // å®æ—¶å‘Šè­¦
    if (error.severity === ErrorSeverity.CRITICAL) {
      await this.alertService.sendAlert(errorReport);
    }
    
    // æ›´æ–°é”™è¯¯ç»Ÿè®¡
    await this.updateErrorMetrics(errorReport);
  }
}
```

### 2. é”™è¯¯æ¢å¤å»ºè®®

``` typescript
class ErrorRecoveryAdvisor {
  getRecoveryAdvice(error: AgentError): RecoveryAdvice {
    switch (error.type) {
      case AgentErrorType.CAD_FILE_PARSE_ERROR:
        return {
          userMessage: 'æ–‡ä»¶æ ¼å¼å¯èƒ½ä¸å—æ”¯æŒï¼Œè¯·å°è¯•è½¬æ¢ä¸ºæ ‡å‡†CADæ ¼å¼',
          technicalSteps: ['æ£€æŸ¥æ–‡ä»¶æ ¼å¼', 'å°è¯•æ–‡ä»¶ä¿®å¤', 'ä½¿ç”¨å¤‡ç”¨è§£æå™¨'],
          autoRecovery: true
        };
        
      case AgentErrorType.POSTER_GENERATION_FAILED:
        return {
          userMessage: 'æµ·æŠ¥ç”Ÿæˆå¤±è´¥ï¼Œæ­£åœ¨ä¸ºæ‚¨é‡æ–°ç”Ÿæˆ',
          technicalSteps: ['é™ä½å›¾ç‰‡è´¨é‡', 'ä½¿ç”¨ç®€åŒ–æ¨¡æ¿', 'é‡Šæ”¾ç³»ç»Ÿèµ„æº'],
          autoRecovery: true
        };
        
      case AgentErrorType.CHAT_CONTEXT_LOST:
        return {
          userMessage: 'å¯¹è¯ä¸Šä¸‹æ–‡å·²é‡ç½®ï¼Œæ‚¨å¯ä»¥ç»§ç»­æ–°çš„å¯¹è¯',
          technicalSteps: ['æ¢å¤ç”¨æˆ·ä¼šè¯', 'é‡å»ºå¯¹è¯ä¸Šä¸‹æ–‡', 'åŒæ­¥å†å²è®°å½•'],
          autoRecovery: false
        };
        
      default:
        return {
          userMessage: 'ç³»ç»Ÿé‡åˆ°é—®é¢˜ï¼Œè¯·ç¨åé‡è¯•',
          technicalSteps: ['æ£€æŸ¥ç³»ç»ŸçŠ¶æ€', 'é‡å¯ç›¸å…³æœåŠ¡', 'è”ç³»æŠ€æœ¯æ”¯æŒ'],
          autoRecovery: false
        };
    }
  }
}
```

## ğŸ¯ å®æ–½è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€æ¡†æ¶ï¼ˆ1-2å‘¨ï¼‰

1.  å»ºç«‹é”™è¯¯åˆ†ç±»ä½“ç³»
2.  å®ç°ç»Ÿä¸€é”™è¯¯å¤„ç†å™¨
3.  éƒ¨ç½²é”™è¯¯æ”¶é›†ç³»ç»Ÿ

### ç¬¬äºŒé˜¶æ®µï¼šæ™ºèƒ½ä½“ä¼˜åŒ–ï¼ˆ2-3å‘¨ï¼‰

1.  CADåˆ†æå®¹é”™æœºåˆ¶
2.  æµ·æŠ¥ç”Ÿæˆé‡è¯•ç­–ç•¥
3.  å¯¹è¯ä¸Šä¸‹æ–‡æ¢å¤

### ç¬¬ä¸‰é˜¶æ®µï¼šç³»ç»Ÿçº§ä¼˜åŒ–ï¼ˆ1-2å‘¨ï¼‰

1.  æ™ºèƒ½ä½“é—´é€šä¿¡å®¹é”™
2.  æœåŠ¡ç†”æ–­æœºåˆ¶
3.  è´Ÿè½½å‡è¡¡ä¼˜åŒ–

### ç¬¬å››é˜¶æ®µï¼šç›‘æ§å®Œå–„ï¼ˆ1å‘¨ï¼‰

1.  é”™è¯¯ç›‘æ§é¢æ¿
2.  è‡ªåŠ¨æ¢å¤æœºåˆ¶
3.  æ€§èƒ½æŒ‡æ ‡æ”¶é›†

## ğŸ“ˆ é¢„æœŸæ•ˆæœ

å®Œæˆä¼˜åŒ–åé¢„æœŸå®ç°ï¼š - ğŸ¯ ç³»ç»Ÿå¯ç”¨æ€§æå‡è‡³99.9% - ğŸ”„
é”™è¯¯è‡ªåŠ¨æ¢å¤ç‡è¾¾åˆ°80% - ğŸ“Š ç”¨æˆ·ä½“éªŒæ»¡æ„åº¦æå‡30% - âš¡
å¹³å‡æ•…éšœæ¢å¤æ—¶é—´ç¼©çŸ­50%
