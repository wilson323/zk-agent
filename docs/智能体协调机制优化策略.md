# ZK-Agent æ™ºèƒ½ä½“åè°ƒæœºåˆ¶ä¼˜åŒ–ç­–ç•¥

## ğŸ“‹ æ¦‚è¿°

æœ¬ç­–ç•¥æ—¨åœ¨ä¼˜åŒ–ZK-Agentå¹³å°ä¸­å¤šæ™ºèƒ½ä½“é—´çš„åè°ƒæœºåˆ¶ï¼Œé€šè¿‡å»ºç«‹é«˜æ•ˆçš„é€šä¿¡åè®®ã€ä»»åŠ¡åˆ†é…ç®—æ³•å’Œå†²çªè§£å†³æœºåˆ¶ï¼Œæå‡æ•´ä½“ç³»ç»Ÿçš„åä½œæ•ˆç‡å’Œç¨³å®šæ€§ã€‚

## ğŸ¯ ä¼˜åŒ–ç›®æ ‡

### 1. åè°ƒæ•ˆç‡æŒ‡æ ‡
- **ä»»åŠ¡åˆ†é…å»¶è¿Ÿ**: â‰¤ 100ms
- **æ™ºèƒ½ä½“å“åº”æ—¶é—´**: â‰¤ 500ms
- **åè°ƒæˆåŠŸç‡**: â‰¥ 99.5%
- **èµ„æºåˆ©ç”¨ç‡**: â‰¥ 85%

### 2. ç³»ç»Ÿç¨³å®šæ€§
- **æ•…éšœæ¢å¤æ—¶é—´**: â‰¤ 30ç§’
- **æ¶ˆæ¯ä¸¢å¤±ç‡**: â‰¤ 0.1%
- **æ­»é”æ£€æµ‹æ—¶é—´**: â‰¤ 5ç§’
- **è´Ÿè½½å‡è¡¡æ•ˆç‡**: â‰¥ 90%

## ğŸ¤– æ™ºèƒ½ä½“æ¶æ„è®¾è®¡

### A. æ™ºèƒ½ä½“åˆ†ç±»å’Œè§’è‰²å®šä¹‰

```typescript
// æ™ºèƒ½ä½“åŸºç¡€æ¥å£
interface Agent {
  id: string;
  type: AgentType;
  capabilities: Capability[];
  status: AgentStatus;
  workload: number;
  priority: number;
}

// æ™ºèƒ½ä½“ç±»å‹æšä¸¾
enum AgentType {
  CAD_ANALYZER = 'cad_analyzer',
  POSTER_GENERATOR = 'poster_generator',
  CHAT_AGENT = 'chat_agent',
  COORDINATOR = 'coordinator',
  MONITOR = 'monitor',
  RESOURCE_MANAGER = 'resource_manager'
}

// æ™ºèƒ½ä½“èƒ½åŠ›å®šä¹‰
interface Capability {
  name: string;
  level: number;        // èƒ½åŠ›ç­‰çº§ 1-10
  resourceCost: number; // èµ„æºæ¶ˆè€—
  maxConcurrency: number; // æœ€å¤§å¹¶å‘æ•°
}

// æ™ºèƒ½ä½“çŠ¶æ€
enum AgentStatus {
  IDLE = 'idle',
  BUSY = 'busy',
  OVERLOADED = 'overloaded',
  ERROR = 'error',
  OFFLINE = 'offline'
}

// åè°ƒå™¨æ™ºèƒ½ä½“
class CoordinatorAgent implements Agent {
  id: string;
  type = AgentType.COORDINATOR;
  capabilities: Capability[];
  status: AgentStatus;
  workload: number = 0;
  priority: number = 10;
  
  private agents = new Map<string, Agent>();
  private taskQueue = new PriorityQueue<Task>();
  private messageRouter: MessageRouter;
  
  constructor(id: string) {
    this.id = id;
    this.capabilities = [
      {
        name: 'task_coordination',
        level: 10,
        resourceCost: 1,
        maxConcurrency: 100
      },
      {
        name: 'resource_allocation',
        level: 9,
        resourceCost: 2,
        maxConcurrency: 50
      }
    ];
    this.status = AgentStatus.IDLE;
    this.messageRouter = new MessageRouter();
  }
  
  // æ³¨å†Œæ™ºèƒ½ä½“
  async registerAgent(agent: Agent): Promise<void> {
    this.agents.set(agent.id, agent);
    
    await this.messageRouter.subscribe(agent.id, (message: Message) => {
      this.handleAgentMessage(agent.id, message);
    });
    
    console.log(`æ™ºèƒ½ä½“ ${agent.id} å·²æ³¨å†Œåˆ°åè°ƒå™¨`);
  }
  
  // ä»»åŠ¡åˆ†é…
  async allocateTask(task: Task): Promise<TaskAllocation> {
    const startTime = Date.now();
    
    try {
      // 1. åˆ†æä»»åŠ¡éœ€æ±‚
      const requirements = await this.analyzeTaskRequirements(task);
      
      // 2. æŸ¥æ‰¾åˆé€‚çš„æ™ºèƒ½ä½“
      const candidates = await this.findSuitableAgents(requirements);
      
      if (candidates.length === 0) {
        throw new Error('æ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„æ™ºèƒ½ä½“å¤„ç†æ­¤ä»»åŠ¡');
      }
      
      // 3. é€‰æ‹©æœ€ä¼˜æ™ºèƒ½ä½“
      const selectedAgent = await this.selectOptimalAgent(candidates, task);
      
      // 4. åˆ†é…ä»»åŠ¡
      const allocation = await this.assignTaskToAgent(selectedAgent, task);
      
      const allocationTime = Date.now() - startTime;
      
      // è®°å½•åˆ†é…æŒ‡æ ‡
      await this.recordAllocationMetrics({
        taskId: task.id,
        agentId: selectedAgent.id,
        allocationTime,
        success: true
      });
      
      return allocation;
      
    } catch (error) {
      const allocationTime = Date.now() - startTime;
      
      await this.recordAllocationMetrics({
        taskId: task.id,
        agentId: null,
        allocationTime,
        success: false,
        error: error.message
      });
      
      throw error;
    }
  }
  
  private async analyzeTaskRequirements(task: Task): Promise<TaskRequirements> {
    return {
      capabilities: task.requiredCapabilities,
      priority: task.priority,
      deadline: task.deadline,
      resourceEstimate: await this.estimateResourceRequirement(task),
      dependencies: task.dependencies || []
    };
  }
  
  private async findSuitableAgents(requirements: TaskRequirements): Promise<Agent[]> {
    const candidates: Agent[] = [];
    
    for (const agent of this.agents.values()) {
      if (agent.status === AgentStatus.OFFLINE || agent.status === AgentStatus.ERROR) {
        continue;
      }
      
      // æ£€æŸ¥èƒ½åŠ›åŒ¹é…
      const hasRequiredCapabilities = requirements.capabilities.every(reqCap => 
        agent.capabilities.some(agentCap => 
          agentCap.name === reqCap.name && agentCap.level >= reqCap.level
        )
      );
      
      if (hasRequiredCapabilities) {
        candidates.push(agent);
      }
    }
    
    return candidates;
  }
  
  private async selectOptimalAgent(candidates: Agent[], task: Task): Promise<Agent> {
    // å¤šå› ç´ è¯„åˆ†ç®—æ³•
    const scores = candidates.map(agent => {
      const workloadScore = (100 - agent.workload) / 100; // å·¥ä½œè´Ÿè½½è¶Šä½è¶Šå¥½
      const capabilityScore = this.calculateCapabilityScore(agent, task);
      const availabilityScore = agent.status === AgentStatus.IDLE ? 1 : 0.5;
      
      return {
        agent,
        score: workloadScore * 0.4 + capabilityScore * 0.4 + availabilityScore * 0.2
      };
    });
    
    // é€‰æ‹©å¾—åˆ†æœ€é«˜çš„æ™ºèƒ½ä½“
    scores.sort((a, b) => b.score - a.score);
    return scores[0].agent;
  }
  
  private calculateCapabilityScore(agent: Agent, task: Task): number {
    let totalScore = 0;
    let totalWeight = 0;
    
    for (const reqCap of task.requiredCapabilities) {
      const agentCap = agent.capabilities.find(cap => cap.name === reqCap.name);
      if (agentCap) {
        const score = Math.min(agentCap.level / reqCap.level, 1);
        totalScore += score * reqCap.weight;
        totalWeight += reqCap.weight;
      }
    }
    
    return totalWeight > 0 ? totalScore / totalWeight : 0;
  }
}
```

### B. æ¶ˆæ¯é€šä¿¡åè®®

```typescript
// æ¶ˆæ¯è·¯ç”±å™¨
class MessageRouter {
  private subscribers = new Map<string, MessageHandler[]>();
  private messageQueue = new Queue<QueuedMessage>();
  private redis: Redis;
  
  constructor() {
    this.redis = new Redis(process.env.REDIS_URL);
    this.startMessageProcessor();
  }
  
  // è®¢é˜…æ¶ˆæ¯
  async subscribe(agentId: string, handler: MessageHandler): Promise<void> {
    if (!this.subscribers.has(agentId)) {
      this.subscribers.set(agentId, []);
    }
    
    this.subscribers.get(agentId)!.push(handler);
    
    // è®¢é˜…Redisé¢‘é“
    await this.redis.subscribe(`agent:${agentId}`);
  }
  
  // å‘é€æ¶ˆæ¯
  async sendMessage(message: Message): Promise<void> {
    const queuedMessage: QueuedMessage = {
      ...message,
      timestamp: Date.now(),
      retryCount: 0
    };
    
    // æ ¹æ®ä¼˜å…ˆçº§å’Œç±»å‹é€‰æ‹©ä¼ è¾“æ–¹å¼
    if (message.priority === MessagePriority.URGENT) {
      await this.sendDirectMessage(queuedMessage);
    } else {
      await this.queueMessage(queuedMessage);
    }
  }
  
  private async sendDirectMessage(message: QueuedMessage): Promise<void> {
    try {
      // ç›´æ¥å‘é€åˆ°Redis
      await this.redis.publish(`agent:${message.to}`, JSON.stringify(message));
      
      // è®°å½•æ¶ˆæ¯æŒ‡æ ‡
      await this.recordMessageMetrics(message, true);
      
    } catch (error) {
      console.error('ç›´æ¥æ¶ˆæ¯å‘é€å¤±è´¥:', error);
      
      // é™çº§åˆ°é˜Ÿåˆ—å‘é€
      await this.queueMessage(message);
    }
  }
  
  private async queueMessage(message: QueuedMessage): Promise<void> {
    this.messageQueue.enqueue(message);
  }
  
  private async startMessageProcessor(): Promise<void> {
    setInterval(async () => {
      await this.processMessageQueue();
    }, 100); // æ¯100mså¤„ç†ä¸€æ¬¡é˜Ÿåˆ—
  }
  
  private async processMessageQueue(): Promise<void> {
    const batchSize = 10;
    const messages: QueuedMessage[] = [];
    
    for (let i = 0; i < batchSize && !this.messageQueue.isEmpty(); i++) {
      messages.push(this.messageQueue.dequeue()!);
    }
    
    if (messages.length === 0) return;
    
    // æ‰¹é‡å¤„ç†æ¶ˆæ¯
    await Promise.allSettled(
      messages.map(message => this.deliverMessage(message))
    );
  }
  
  private async deliverMessage(message: QueuedMessage): Promise<void> {
    try {
      const handlers = this.subscribers.get(message.to);
      
      if (!handlers || handlers.length === 0) {
        throw new Error(`æ²¡æœ‰æ‰¾åˆ°æ¥æ”¶è€…: ${message.to}`);
      }
      
      // å¹¶è¡Œè°ƒç”¨æ‰€æœ‰å¤„ç†å™¨
      await Promise.all(
        handlers.map(handler => handler(message))
      );
      
      await this.recordMessageMetrics(message, true);
      
    } catch (error) {
      console.error('æ¶ˆæ¯ä¼ é€’å¤±è´¥:', error);
      
      // é‡è¯•æœºåˆ¶
      if (message.retryCount < 3) {
        message.retryCount++;
        message.timestamp = Date.now();
        
        // å»¶è¿Ÿé‡è¯•
        setTimeout(() => {
          this.messageQueue.enqueue(message);
        }, Math.pow(2, message.retryCount) * 1000);
      } else {
        await this.recordMessageMetrics(message, false);
        console.error('æ¶ˆæ¯æœ€ç»ˆå‘é€å¤±è´¥:', message);
      }
    }
  }
}

// æ¶ˆæ¯ç±»å‹å®šä¹‰
interface Message {
  id: string;
  from: string;
  to: string;
  type: MessageType;
  payload: any;
  priority: MessagePriority;
  correlationId?: string;
}

enum MessageType {
  TASK_REQUEST = 'task_request',
  TASK_RESPONSE = 'task_response',
  STATUS_UPDATE = 'status_update',
  RESOURCE_REQUEST = 'resource_request',
  COORDINATION_REQUEST = 'coordination_request',
  HEARTBEAT = 'heartbeat'
}

enum MessagePriority {
  LOW = 1,
  NORMAL = 2,
  HIGH = 3,
  URGENT = 4
}
```

## âš–ï¸ è´Ÿè½½å‡è¡¡å’Œèµ„æºç®¡ç†

### A. åŠ¨æ€è´Ÿè½½å‡è¡¡

```typescript
// è´Ÿè½½å‡è¡¡å™¨
class LoadBalancer {
  private agents = new Map<string, Agent>();
  private loadMetrics = new Map<string, LoadMetrics>();
  private balancingStrategy: BalancingStrategy;
  
  constructor(strategy: BalancingStrategy = BalancingStrategy.WEIGHTED_ROUND_ROBIN) {
    this.balancingStrategy = strategy;
    this.startLoadMonitoring();
  }
  
  // é€‰æ‹©æ™ºèƒ½ä½“
  async selectAgent(task: Task): Promise<Agent | null> {
    const availableAgents = Array.from(this.agents.values())
      .filter(agent => 
        agent.status !== AgentStatus.OFFLINE && 
        agent.status !== AgentStatus.ERROR &&
        this.canHandleTask(agent, task)
      );
    
    if (availableAgents.length === 0) {
      return null;
    }
    
    switch (this.balancingStrategy) {
      case BalancingStrategy.ROUND_ROBIN:
        return this.roundRobinSelection(availableAgents);
      
      case BalancingStrategy.WEIGHTED_ROUND_ROBIN:
        return this.weightedRoundRobinSelection(availableAgents);
      
      case BalancingStrategy.LEAST_CONNECTIONS:
        return this.leastConnectionsSelection(availableAgents);
      
      case BalancingStrategy.RESOURCE_BASED:
        return this.resourceBasedSelection(availableAgents, task);
      
      default:
        return availableAgents[0];
    }
  }
  
  private weightedRoundRobinSelection(agents: Agent[]): Agent {
    // åŸºäºæ€§èƒ½å’Œè´Ÿè½½çš„åŠ æƒè½®è¯¢
    const weights = agents.map(agent => {
      const metrics = this.loadMetrics.get(agent.id);
      if (!metrics) return 1;
      
      // è®¡ç®—æƒé‡ï¼šæ€§èƒ½è¶Šé«˜ã€è´Ÿè½½è¶Šä½ï¼Œæƒé‡è¶Šå¤§
      const performanceWeight = metrics.averageResponseTime > 0 
        ? 1000 / metrics.averageResponseTime 
        : 1;
      const loadWeight = Math.max(0.1, 1 - (agent.workload / 100));
      
      return performanceWeight * loadWeight;
    });
    
    // åŠ æƒéšæœºé€‰æ‹©
    const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
    let random = Math.random() * totalWeight;
    
    for (let i = 0; i < agents.length; i++) {
      random -= weights[i];
      if (random <= 0) {
        return agents[i];
      }
    }
    
    return agents[agents.length - 1];
  }
  
  private resourceBasedSelection(agents: Agent[], task: Task): Agent {
    // åŸºäºèµ„æºéœ€æ±‚çš„æ™ºèƒ½é€‰æ‹©
    const scores = agents.map(agent => {
      const metrics = this.loadMetrics.get(agent.id);
      if (!metrics) return { agent, score: 0 };
      
      // è®¡ç®—èµ„æºåŒ¹é…åº¦
      const cpuScore = Math.max(0, 1 - metrics.cpuUsage / 100);
      const memoryScore = Math.max(0, 1 - metrics.memoryUsage / 100);
      const networkScore = Math.max(0, 1 - metrics.networkUsage / 100);
      
      // è®¡ç®—ä»»åŠ¡é€‚é…åº¦
      const taskScore = this.calculateTaskFitScore(agent, task);
      
      const totalScore = (cpuScore + memoryScore + networkScore) / 3 * 0.6 + taskScore * 0.4;
      
      return { agent, score: totalScore };
    });
    
    // é€‰æ‹©å¾—åˆ†æœ€é«˜çš„æ™ºèƒ½ä½“
    scores.sort((a, b) => b.score - a.score);
    return scores[0].agent;
  }
  
  private calculateTaskFitScore(agent: Agent, task: Task): number {
    // è®¡ç®—æ™ºèƒ½ä½“ä¸ä»»åŠ¡çš„åŒ¹é…åº¦
    let matchScore = 0;
    let totalRequirements = 0;
    
    for (const requirement of task.requiredCapabilities) {
      const capability = agent.capabilities.find(cap => cap.name === requirement.name);
      if (capability) {
        const score = Math.min(capability.level / requirement.level, 1);
        matchScore += score * requirement.weight;
      }
      totalRequirements += requirement.weight;
    }
    
    return totalRequirements > 0 ? matchScore / totalRequirements : 0;
  }
  
  // è´Ÿè½½ç›‘æ§
  private startLoadMonitoring(): void {
    setInterval(async () => {
      await this.updateLoadMetrics();
      await this.checkLoadBalance();
    }, 5000); // æ¯5ç§’æ›´æ–°ä¸€æ¬¡
  }
  
  private async updateLoadMetrics(): Promise<void> {
    for (const agent of this.agents.values()) {
      try {
        const metrics = await this.collectAgentMetrics(agent.id);
        this.loadMetrics.set(agent.id, metrics);
        
        // æ›´æ–°æ™ºèƒ½ä½“çŠ¶æ€
        agent.workload = metrics.currentLoad;
        
        if (metrics.currentLoad > 90) {
          agent.status = AgentStatus.OVERLOADED;
        } else if (metrics.currentLoad > 70) {
          agent.status = AgentStatus.BUSY;
        } else {
          agent.status = AgentStatus.IDLE;
        }
        
      } catch (error) {
        console.error(`è·å–æ™ºèƒ½ä½“ ${agent.id} æŒ‡æ ‡å¤±è´¥:`, error);
        agent.status = AgentStatus.ERROR;
      }
    }
  }
  
  private async checkLoadBalance(): Promise<void> {
    const agents = Array.from(this.agents.values());
    const loads = agents.map(agent => agent.workload);
    
    if (loads.length < 2) return;
    
    const avgLoad = loads.reduce((sum, load) => sum + load, 0) / loads.length;
    const maxLoad = Math.max(...loads);
    const minLoad = Math.min(...loads);
    
    // æ£€æŸ¥è´Ÿè½½ä¸å‡è¡¡
    const loadImbalance = maxLoad - minLoad;
    const imbalanceThreshold = 30; // 30%çš„è´Ÿè½½å·®å¼‚é˜ˆå€¼
    
    if (loadImbalance > imbalanceThreshold) {
      await this.rebalanceLoad(agents, avgLoad);
    }
  }
  
  private async rebalanceLoad(agents: Agent[], targetLoad: number): Promise<void> {
    const overloadedAgents = agents.filter(agent => agent.workload > targetLoad + 15);
    const underloadedAgents = agents.filter(agent => agent.workload < targetLoad - 15);
    
    if (overloadedAgents.length === 0 || underloadedAgents.length === 0) {
      return;
    }
    
    console.log('å¼€å§‹è´Ÿè½½é‡å¹³è¡¡...');
    
    // å®æ–½è´Ÿè½½è¿ç§»ç­–ç•¥
    for (const overloadedAgent of overloadedAgents) {
      const tasksToMigrate = await this.identifyMigratableTasks(overloadedAgent.id);
      
      for (const task of tasksToMigrate) {
        const targetAgent = this.findBestMigrationTarget(underloadedAgents, task);
        if (targetAgent) {
          await this.migrateTask(task, overloadedAgent.id, targetAgent.id);
        }
      }
    }
  }
}

// è´Ÿè½½æŒ‡æ ‡æ¥å£
interface LoadMetrics {
  currentLoad: number;
  averageResponseTime: number;
  cpuUsage: number;
  memoryUsage: number;
  networkUsage: number;
  activeConnections: number;
  queueLength: number;
  errorRate: number;
}

enum BalancingStrategy {
  ROUND_ROBIN = 'round_robin',
  WEIGHTED_ROUND_ROBIN = 'weighted_round_robin',
  LEAST_CONNECTIONS = 'least_connections',
  RESOURCE_BASED = 'resource_based'
}
```

## ğŸ”„ æ•…éšœæ£€æµ‹å’Œæ¢å¤

### A. å¥åº·æ£€æŸ¥æœºåˆ¶

```typescript
// å¥åº·æ£€æŸ¥æœåŠ¡
class HealthCheckService {
  private agents = new Map<string, Agent>();
  private healthStatus = new Map<string, HealthStatus>();
  private checkInterval = 10000; // 10ç§’
  private timeoutThreshold = 5000; // 5ç§’è¶…æ—¶
  
  constructor() {
    this.startHealthChecking();
  }
  
  // æ³¨å†Œæ™ºèƒ½ä½“å¥åº·æ£€æŸ¥
  registerAgent(agent: Agent): void {
    this.agents.set(agent.id, agent);
    this.healthStatus.set(agent.id, {
      status: HealthStatusType.HEALTHY,
      lastCheck: Date.now(),
      consecutiveFailures: 0,
      responseTime: 0
    });
  }
  
  // å¼€å§‹å¥åº·æ£€æŸ¥
  private startHealthChecking(): void {
    setInterval(async () => {
      await this.performHealthChecks();
    }, this.checkInterval);
  }
  
  private async performHealthChecks(): Promise<void> {
    const checkPromises = Array.from(this.agents.keys()).map(agentId => 
      this.checkAgentHealth(agentId)
    );
    
    await Promise.allSettled(checkPromises);
  }
  
  private async checkAgentHealth(agentId: string): Promise<void> {
    const startTime = Date.now();
    
    try {
      // å‘é€å¥åº·æ£€æŸ¥è¯·æ±‚
      const response = await this.sendHealthCheckRequest(agentId);
      const responseTime = Date.now() - startTime;
      
      if (response.status === 'ok' && responseTime < this.timeoutThreshold) {
        await this.markAgentHealthy(agentId, responseTime);
      } else {
        await this.markAgentUnhealthy(agentId, 'slow_response');
      }
      
    } catch (error) {
      await this.markAgentUnhealthy(agentId, error.message);
    }
  }
  
  private async sendHealthCheckRequest(agentId: string): Promise<HealthCheckResponse> {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('å¥åº·æ£€æŸ¥è¶…æ—¶'));
      }, this.timeoutThreshold);
      
      // æ¨¡æ‹Ÿå¥åº·æ£€æŸ¥è¯·æ±‚
      // å®é™…å®ç°ä¸­åº”è¯¥å‘é€çœŸå®çš„HTTPè¯·æ±‚æˆ–æ¶ˆæ¯
      const agent = this.agents.get(agentId);
      if (agent && agent.status !== AgentStatus.OFFLINE) {
        clearTimeout(timeout);
        resolve({ status: 'ok', timestamp: Date.now() });
      } else {
        clearTimeout(timeout);
        reject(new Error('æ™ºèƒ½ä½“ç¦»çº¿'));
      }
    });
  }
  
  private async markAgentHealthy(agentId: string, responseTime: number): Promise<void> {
    const health = this.healthStatus.get(agentId);
    if (health) {
      health.status = HealthStatusType.HEALTHY;
      health.lastCheck = Date.now();
      health.consecutiveFailures = 0;
      health.responseTime = responseTime;
      
      // å¦‚æœæ™ºèƒ½ä½“ä¹‹å‰æ˜¯ä¸å¥åº·çš„ï¼Œç°åœ¨æ¢å¤äº†
      const agent = this.agents.get(agentId);
      if (agent && agent.status === AgentStatus.ERROR) {
        agent.status = AgentStatus.IDLE;
        await this.notifyAgentRecovery(agentId);
      }
    }
  }
  
  private async markAgentUnhealthy(agentId: string, reason: string): Promise<void> {
    const health = this.healthStatus.get(agentId);
    if (health) {
      health.consecutiveFailures++;
      health.lastCheck = Date.now();
      
      // æ ¹æ®è¿ç»­å¤±è´¥æ¬¡æ•°å†³å®šçŠ¶æ€
      if (health.consecutiveFailures >= 3) {
        health.status = HealthStatusType.CRITICAL;
        
        const agent = this.agents.get(agentId);
        if (agent) {
          agent.status = AgentStatus.ERROR;
          await this.handleAgentFailure(agentId, reason);
        }
      } else {
        health.status = HealthStatusType.WARNING;
      }
    }
  }
  
  private async handleAgentFailure(agentId: string, reason: string): Promise<void> {
    console.log(`æ™ºèƒ½ä½“ ${agentId} æ•…éšœ: ${reason}`);
    
    // 1. è®°å½•æ•…éšœäº‹ä»¶
    await this.logFailureEvent(agentId, reason);
    
    // 2. è¿ç§»æ­£åœ¨å¤„ç†çš„ä»»åŠ¡
    await this.migrateActiveTasks(agentId);
    
    // 3. é€šçŸ¥åè°ƒå™¨
    await this.notifyCoordinator(agentId, 'agent_failed');
    
    // 4. å°è¯•é‡å¯æ™ºèƒ½ä½“
    await this.attemptAgentRestart(agentId);
  }
  
  private async migrateActiveTasks(failedAgentId: string): Promise<void> {
    try {
      // è·å–å¤±è´¥æ™ºèƒ½ä½“çš„æ´»è·ƒä»»åŠ¡
      const activeTasks = await this.getActiveTasks(failedAgentId);
      
      for (const task of activeTasks) {
        // æŸ¥æ‰¾å¤‡ç”¨æ™ºèƒ½ä½“
        const backupAgent = await this.findBackupAgent(task);
        
        if (backupAgent) {
          await this.transferTask(task, failedAgentId, backupAgent.id);
          console.log(`ä»»åŠ¡ ${task.id} å·²ä» ${failedAgentId} è¿ç§»åˆ° ${backupAgent.id}`);
        } else {
          // å¦‚æœæ²¡æœ‰å¤‡ç”¨æ™ºèƒ½ä½“ï¼Œå°†ä»»åŠ¡é‡æ–°åŠ å…¥é˜Ÿåˆ—
          await this.requeueTask(task);
          console.log(`ä»»åŠ¡ ${task.id} å·²é‡æ–°åŠ å…¥é˜Ÿåˆ—`);
        }
      }
    } catch (error) {
      console.error('ä»»åŠ¡è¿ç§»å¤±è´¥:', error);
    }
  }
  
  private async attemptAgentRestart(agentId: string): Promise<void> {
    try {
      console.log(`å°è¯•é‡å¯æ™ºèƒ½ä½“ ${agentId}`);
      
      // å®é™…å®ç°ä¸­åº”è¯¥è°ƒç”¨å®¹å™¨ç¼–æ’ç³»ç»Ÿçš„é‡å¯API
      // è¿™é‡Œæ¨¡æ‹Ÿé‡å¯è¿‡ç¨‹
      await new Promise(resolve => setTimeout(resolve, 5000));
      
      // é‡æ–°æ³¨å†Œæ™ºèƒ½ä½“
      const agent = this.agents.get(agentId);
      if (agent) {
        agent.status = AgentStatus.IDLE;
        await this.markAgentHealthy(agentId, 0);
        console.log(`æ™ºèƒ½ä½“ ${agentId} é‡å¯æˆåŠŸ`);
      }
      
    } catch (error) {
      console.error(`æ™ºèƒ½ä½“ ${agentId} é‡å¯å¤±è´¥:`, error);
    }
  }
}

// å¥åº·çŠ¶æ€æ¥å£
interface HealthStatus {
  status: HealthStatusType;
  lastCheck: number;
  consecutiveFailures: number;
  responseTime: number;
}

enum HealthStatusType {
  HEALTHY = 'healthy',
  WARNING = 'warning',
  CRITICAL = 'critical'
}

interface HealthCheckResponse {
  status: string;
  timestamp: number;
}
```

## ğŸ“Š æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–

### A. åè°ƒæ€§èƒ½ç›‘æ§

```typescript
// åè°ƒæ€§èƒ½ç›‘æ§æœåŠ¡
class CoordinationMetricsService {
  private metrics = new Map<string, CoordinationMetrics>();
  private alertThresholds: AlertThresholds;
  
  constructor() {
    this.alertThresholds = {
      taskAllocationTime: 100,    // 100ms
      agentResponseTime: 500,     // 500ms
      coordinationSuccessRate: 99.5, // 99.5%
      messageDeliveryRate: 99.9   // 99.9%
    };
    
    this.startMetricsCollection();
  }
  
  // è®°å½•ä»»åŠ¡åˆ†é…æŒ‡æ ‡
  async recordTaskAllocation(allocation: TaskAllocationMetrics): Promise<void> {
    const key = `task_allocation:${Date.now()}`;
    
    this.metrics.set(key, {
      type: 'task_allocation',
      timestamp: Date.now(),
      data: allocation
    });
    
    // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é˜ˆå€¼
    if (allocation.allocationTime > this.alertThresholds.taskAllocationTime) {
      await this.sendAlert('task_allocation_slow', {
        allocationTime: allocation.allocationTime,
        threshold: this.alertThresholds.taskAllocationTime,
        taskId: allocation.taskId
      });
    }
  }
  
  // è®°å½•æ™ºèƒ½ä½“å“åº”æŒ‡æ ‡
  async recordAgentResponse(response: AgentResponseMetrics): Promise<void> {
    const key = `agent_response:${response.agentId}:${Date.now()}`;
    
    this.metrics.set(key, {
      type: 'agent_response',
      timestamp: Date.now(),
      data: response
    });
    
    if (response.responseTime > this.alertThresholds.agentResponseTime) {
      await this.sendAlert('agent_response_slow', {
        agentId: response.agentId,
        responseTime: response.responseTime,
        threshold: this.alertThresholds.agentResponseTime
      });
    }
  }
  
  // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
  async generatePerformanceReport(timeRange: TimeRange): Promise<PerformanceReport> {
    const startTime = timeRange.start;
    const endTime = timeRange.end;
    
    // æ”¶é›†æŒ‡æ ‡æ•°æ®
    const allocationMetrics = this.getMetricsByType('task_allocation', startTime, endTime);
    const responseMetrics = this.getMetricsByType('agent_response', startTime, endTime);
    
    // è®¡ç®—ç»Ÿè®¡æ•°æ®
    const allocationStats = this.calculateAllocationStats(allocationMetrics);
    const responseStats = this.calculateResponseStats(responseMetrics);
    
    return {
      timeRange,
      taskAllocation: {
        totalTasks: allocationStats.count,
        averageTime: allocationStats.averageTime,
        p95Time: allocationStats.p95Time,
        successRate: allocationStats.successRate
      },
      agentResponse: {
        totalResponses: responseStats.count,
        averageTime: responseStats.averageTime,
        p95Time: responseStats.p95Time,
        errorRate: responseStats.errorRate
      },
      coordination: {
        overallSuccessRate: this.calculateOverallSuccessRate(allocationStats, responseStats),
        bottlenecks: await this.identifyBottlenecks(allocationMetrics, responseMetrics),
        recommendations: await this.generateOptimizationRecommendations(allocationStats, responseStats)
      }
    };
  }
  
  private calculateAllocationStats(metrics: CoordinationMetrics[]): AllocationStats {
    if (metrics.length === 0) {
      return { count: 0, averageTime: 0, p95Time: 0, successRate: 100 };
    }
    
    const times = metrics.map(m => (m.data as TaskAllocationMetrics).allocationTime);
    const successes = metrics.filter(m => (m.data as TaskAllocationMetrics).success).length;
    
    times.sort((a, b) => a - b);
    
    return {
      count: metrics.length,
      averageTime: times.reduce((sum, time) => sum + time, 0) / times.length,
      p95Time: times[Math.floor(times.length * 0.95)],
      successRate: (successes / metrics.length) * 100
    };
  }
  
  private async identifyBottlenecks(allocationMetrics: CoordinationMetrics[], responseMetrics: CoordinationMetrics[]): Promise<Bottleneck[]> {
    const bottlenecks: Bottleneck[] = [];
    
    // åˆ†æä»»åŠ¡åˆ†é…ç“¶é¢ˆ
    const slowAllocations = allocationMetrics.filter(m => 
      (m.data as TaskAllocationMetrics).allocationTime > this.alertThresholds.taskAllocationTime
    );
    
    if (slowAllocations.length > allocationMetrics.length * 0.1) {
      bottlenecks.push({
        type: 'task_allocation',
        severity: 'high',
        description: 'ä»»åŠ¡åˆ†é…å»¶è¿Ÿè¿‡é«˜',
        affectedCount: slowAllocations.length,
        recommendation: 'è€ƒè™‘å¢åŠ åè°ƒå™¨å®ä¾‹æˆ–ä¼˜åŒ–åˆ†é…ç®—æ³•'
      });
    }
    
    // åˆ†ææ™ºèƒ½ä½“å“åº”ç“¶é¢ˆ
    const agentResponseTimes = new Map<string, number[]>();
    
    responseMetrics.forEach(m => {
      const data = m.data as AgentResponseMetrics;
      if (!agentResponseTimes.has(data.agentId)) {
        agentResponseTimes.set(data.agentId, []);
      }
      agentResponseTimes.get(data.agentId)!.push(data.responseTime);
    });
    
    for (const [agentId, times] of agentResponseTimes) {
      const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length;
      
      if (avgTime > this.alertThresholds.agentResponseTime) {
        bottlenecks.push({
          type: 'agent_response',
          severity: 'medium',
          description: `æ™ºèƒ½ä½“ ${agentId} å“åº”æ—¶é—´è¿‡é•¿`,
          affectedCount: times.length,
          recommendation: 'æ£€æŸ¥æ™ºèƒ½ä½“èµ„æºä½¿ç”¨æƒ…å†µï¼Œè€ƒè™‘æ‰©å®¹æˆ–ä¼˜åŒ–'
        });
      }
    }
    
    return bottlenecks;
  }
}

// æ€§èƒ½æŒ‡æ ‡æ¥å£
interface CoordinationMetrics {
  type: string;
  timestamp: number;
  data: any;
}

interface TaskAllocationMetrics {
  taskId: string;
  agentId: string | null;
  allocationTime: number;
  success: boolean;
  error?: string;
}

interface AgentResponseMetrics {
  agentId: string;
  taskId: string;
  responseTime: number;
  success: boolean;
  error?: string;
}

interface PerformanceReport {
  timeRange: TimeRange;
  taskAllocation: AllocationStats;
  agentResponse: ResponseStats;
  coordination: CoordinationStats;
}

interface Bottleneck {
  type: string;
  severity: 'low' | 'medium' | 'high';
  description: string;
  affectedCount: number;
  recommendation: string;
}
```

## ğŸš€ å®æ–½è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€æ¶æ„æ­å»ºï¼ˆ2å‘¨ï¼‰
1. æ™ºèƒ½ä½“æ³¨å†Œå’Œå‘ç°æœºåˆ¶
2. æ¶ˆæ¯è·¯ç”±ç³»ç»Ÿå®ç°
3. åŸºç¡€åè°ƒå™¨å¼€å‘

### ç¬¬äºŒé˜¶æ®µï¼šè´Ÿè½½å‡è¡¡ä¼˜åŒ–ï¼ˆ2å‘¨ï¼‰
1. åŠ¨æ€è´Ÿè½½å‡è¡¡ç®—æ³•
2. èµ„æºç›‘æ§ç³»ç»Ÿ
3. ä»»åŠ¡åˆ†é…ä¼˜åŒ–

### ç¬¬ä¸‰é˜¶æ®µï¼šæ•…éšœæ¢å¤æœºåˆ¶ï¼ˆ2å‘¨ï¼‰
1. å¥åº·æ£€æŸ¥ç³»ç»Ÿ
2. æ•…éšœæ£€æµ‹å’Œæ¢å¤
3. ä»»åŠ¡è¿ç§»æœºåˆ¶

### ç¬¬å››é˜¶æ®µï¼šæ€§èƒ½ç›‘æ§å®Œå–„ï¼ˆ1å‘¨ï¼‰
1. æ€§èƒ½æŒ‡æ ‡æ”¶é›†
2. ç›‘æ§ä»ªè¡¨æ¿
3. å‘Šè­¦ç³»ç»Ÿå®Œå–„

## ğŸ“ˆ é¢„æœŸæ•ˆæœ

å®Œæˆä¼˜åŒ–åé¢„æœŸå®ç°ï¼š
- âš¡ ä»»åŠ¡åˆ†é…å»¶è¿Ÿâ‰¤100ms
- ğŸ¤– æ™ºèƒ½ä½“å“åº”æ—¶é—´â‰¤500ms
- ğŸ¯ åè°ƒæˆåŠŸç‡â‰¥99.5%
- ğŸ“Š ç³»ç»Ÿèµ„æºåˆ©ç”¨ç‡â‰¥85%
- ğŸ”„ æ•…éšœæ¢å¤æ—¶é—´â‰¤30ç§’