# ZK-Agent å®‰å…¨æœºåˆ¶å¼ºåŒ–ç­–ç•¥

## ğŸ“‹ æ¦‚è¿°

æœ¬ç­–ç•¥æ—¨åœ¨å…¨é¢æå‡ZK-Agentå¹³å°çš„å®‰å…¨é˜²æŠ¤èƒ½åŠ›ï¼Œé€šè¿‡å¤šå±‚æ¬¡çš„å®‰å…¨æœºåˆ¶å»ºè®¾ï¼Œç¡®ä¿ç³»ç»Ÿåœ¨å„ç§å®‰å…¨å¨èƒä¸‹çš„ç¨³å®šè¿è¡Œå’Œæ•°æ®å®‰å…¨ã€‚

## ğŸ¯ å®‰å…¨ç›®æ ‡

### 1. å®‰å…¨é˜²æŠ¤æŒ‡æ ‡
- **é›¶æ•°æ®æ³„éœ²**: 100%æ•°æ®å®‰å…¨ä¿æŠ¤
- **èº«ä»½è®¤è¯å¼ºåº¦**: å¤šå› ç´ è®¤è¯è¦†ç›–ç‡100%
- **APIå®‰å…¨**: æ‰€æœ‰æ¥å£å®‰å…¨é˜²æŠ¤è¦†ç›–
- **æ¼æ´å“åº”æ—¶é—´**: â‰¤ 24å°æ—¶

### 2. åˆè§„è¦æ±‚
- **æ•°æ®ä¿æŠ¤**: ç¬¦åˆGDPRã€CCPAç­‰æ³•è§„
- **å®‰å…¨æ ‡å‡†**: éµå¾ªOWASP Top 10
- **å®¡è®¡è¦æ±‚**: å®Œæ•´çš„å®‰å…¨å®¡è®¡æ—¥å¿—
- **åŠ å¯†æ ‡å‡†**: AES-256ã€RSA-2048ç­‰

## ğŸ” èº«ä»½è®¤è¯å’Œæˆæƒå¼ºåŒ–

### A. å¤šå› ç´ è®¤è¯(MFA)

```typescript
// å¤šå› ç´ è®¤è¯å®ç°
class MultiFactorAuth {
  private totpService: TOTPService;
  private smsService: SMSService;
  private emailService: EmailService;
  
  constructor() {
    this.totpService = new TOTPService();
    this.smsService = new SMSService();
    this.emailService = new EmailService();
  }
  
  async enableMFA(userId: string, method: MFAMethod): Promise<MFASetupResult> {
    switch (method) {
      case 'totp':
        return await this.setupTOTP(userId);
      case 'sms':
        return await this.setupSMS(userId);
      case 'email':
        return await this.setupEmail(userId);
      default:
        throw new Error('ä¸æ”¯æŒçš„MFAæ–¹æ³•');
    }
  }
  
  private async setupTOTP(userId: string): Promise<MFASetupResult> {
    const secret = this.totpService.generateSecret();
    const qrCode = await this.totpService.generateQRCode(userId, secret);
    
    // ä¸´æ—¶å­˜å‚¨secretï¼Œç­‰å¾…ç”¨æˆ·éªŒè¯
    await this.storeTempSecret(userId, secret);
    
    return {
      method: 'totp',
      secret,
      qrCode,
      backupCodes: this.generateBackupCodes()
    };
  }
  
  async verifyMFA(userId: string, method: MFAMethod, code: string): Promise<boolean> {
    try {
      switch (method) {
        case 'totp':
          return await this.verifyTOTP(userId, code);
        case 'sms':
          return await this.verifySMS(userId, code);
        case 'email':
          return await this.verifyEmail(userId, code);
        default:
          return false;
      }
    } catch (error) {
      // è®°å½•å®‰å…¨äº‹ä»¶
      await this.logSecurityEvent(userId, 'mfa_verification_failed', {
        method,
        error: error.message,
        timestamp: new Date().toISOString()
      });
      return false;
    }
  }
  
  private generateBackupCodes(): string[] {
    const codes = [];
    for (let i = 0; i < 10; i++) {
      codes.push(crypto.randomBytes(4).toString('hex').toUpperCase());
    }
    return codes;
  }
}
```

### B. åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶(RBAC)

```typescript
// RBACæƒé™ç®¡ç†
class RBACManager {
  private permissions = new Map<string, Permission[]>();
  private roles = new Map<string, Role>();
  private userRoles = new Map<string, string[]>();
  
  constructor() {
    this.initializeDefaultRoles();
  }
  
  private initializeDefaultRoles() {
    // å®šä¹‰é»˜è®¤è§’è‰²å’Œæƒé™
    const roles = [
      {
        name: 'admin',
        permissions: [
          'user:create', 'user:read', 'user:update', 'user:delete',
          'cad:analyze', 'cad:manage',
          'poster:generate', 'poster:manage',
          'system:monitor', 'system:configure'
        ]
      },
      {
        name: 'user',
        permissions: [
          'user:read', 'user:update',
          'cad:analyze',
          'poster:generate'
        ]
      },
      {
        name: 'viewer',
        permissions: [
          'user:read',
          'cad:view',
          'poster:view'
        ]
      }
    ];
    
    roles.forEach(role => {
      this.roles.set(role.name, {
        name: role.name,
        permissions: role.permissions
      });
    });
  }
  
  async checkPermission(userId: string, resource: string, action: string): Promise<boolean> {
    const userRoles = await this.getUserRoles(userId);
    const requiredPermission = `${resource}:${action}`;
    
    for (const roleName of userRoles) {
      const role = this.roles.get(roleName);
      if (role && role.permissions.includes(requiredPermission)) {
        return true;
      }
    }
    
    // è®°å½•æƒé™æ£€æŸ¥å¤±è´¥
    await this.logSecurityEvent(userId, 'permission_denied', {
      resource,
      action,
      userRoles,
      timestamp: new Date().toISOString()
    });
    
    return false;
  }
  
  // æƒé™ä¸­é—´ä»¶
  requirePermission(resource: string, action: string) {
    return async (req: Request, res: Response, next: NextFunction) => {
      const userId = req.user?.id;
      
      if (!userId) {
        return res.status(401).json({ error: 'æœªè®¤è¯ç”¨æˆ·' });
      }
      
      const hasPermission = await this.checkPermission(userId, resource, action);
      
      if (!hasPermission) {
        return res.status(403).json({ error: 'æƒé™ä¸è¶³' });
      }
      
      next();
    };
  }
}
```

## ğŸ›¡ï¸ æ•°æ®å®‰å…¨ä¿æŠ¤

### A. æ•°æ®åŠ å¯†

```typescript
// æ•°æ®åŠ å¯†æœåŠ¡
class EncryptionService {
  private algorithm = 'aes-256-gcm';
  private keyDerivation = 'pbkdf2';
  
  // åŠ å¯†æ•æ„Ÿæ•°æ®
  async encryptSensitiveData(data: string, context: string): Promise<EncryptedData> {
    const key = await this.deriveKey(context);
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipher(this.algorithm, key);
    
    cipher.setAAD(Buffer.from(context));
    
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    
    const authTag = cipher.getAuthTag();
    
    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex'),
      algorithm: this.algorithm
    };
  }
  
  // è§£å¯†æ•æ„Ÿæ•°æ®
  async decryptSensitiveData(encryptedData: EncryptedData, context: string): Promise<string> {
    const key = await this.deriveKey(context);
    const decipher = crypto.createDecipher(this.algorithm, key);
    
    decipher.setAAD(Buffer.from(context));
    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));
    
    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    
    return decrypted;
  }
  
  // å¯†é’¥æ´¾ç”Ÿ
  private async deriveKey(context: string): Promise<Buffer> {
    const masterKey = process.env.MASTER_ENCRYPTION_KEY;
    if (!masterKey) {
      throw new Error('ä¸»åŠ å¯†å¯†é’¥æœªé…ç½®');
    }
    
    return crypto.pbkdf2Sync(masterKey, context, 100000, 32, 'sha256');
  }
  
  // å­—æ®µçº§åŠ å¯†
  async encryptDatabaseField(tableName: string, fieldName: string, value: string): Promise<string> {
    const context = `${tableName}.${fieldName}`;
    const encrypted = await this.encryptSensitiveData(value, context);
    return JSON.stringify(encrypted);
  }
  
  async decryptDatabaseField(tableName: string, fieldName: string, encryptedValue: string): Promise<string> {
    const context = `${tableName}.${fieldName}`;
    const encrypted = JSON.parse(encryptedValue);
    return await this.decryptSensitiveData(encrypted, context);
  }
}

// æ•°æ®è„±æ•æœåŠ¡
class DataMaskingService {
  // æ‰‹æœºå·è„±æ•
  maskPhoneNumber(phone: string): string {
    if (!phone || phone.length < 11) return phone;
    return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
  }
  
  // é‚®ç®±è„±æ•
  maskEmail(email: string): string {
    if (!email || !email.includes('@')) return email;
    const [username, domain] = email.split('@');
    const maskedUsername = username.length > 2 
      ? username.substring(0, 2) + '*'.repeat(username.length - 2)
      : username;
    return `${maskedUsername}@${domain}`;
  }
  
  // èº«ä»½è¯å·è„±æ•
  maskIdCard(idCard: string): string {
    if (!idCard || idCard.length < 18) return idCard;
    return idCard.replace(/(\d{6})\d{8}(\d{4})/, '$1********$2');
  }
  
  // è‡ªåŠ¨è„±æ•ä¸­é—´ä»¶
  autoMaskResponse() {
    return (req: Request, res: Response, next: NextFunction) => {
      const originalJson = res.json;
      
      res.json = function(data: any) {
        const maskedData = this.maskSensitiveFields(data);
        return originalJson.call(this, maskedData);
      }.bind(this);
      
      next();
    };
  }
  
  private maskSensitiveFields(data: any): any {
    if (Array.isArray(data)) {
      return data.map(item => this.maskSensitiveFields(item));
    }
    
    if (typeof data === 'object' && data !== null) {
      const masked = { ...data };
      
      Object.keys(masked).forEach(key => {
        if (key.includes('phone')) {
          masked[key] = this.maskPhoneNumber(masked[key]);
        } else if (key.includes('email')) {
          masked[key] = this.maskEmail(masked[key]);
        } else if (key.includes('idCard')) {
          masked[key] = this.maskIdCard(masked[key]);
        } else if (typeof masked[key] === 'object') {
          masked[key] = this.maskSensitiveFields(masked[key]);
        }
      });
      
      return masked;
    }
    
    return data;
  }
}
```

## ğŸ”’ APIå®‰å…¨é˜²æŠ¤

### A. APIé™æµå’Œé˜²æŠ¤

```typescript
// APIé™æµæœåŠ¡
class RateLimitService {
  private redis: Redis;
  private limits = new Map<string, RateLimit>();
  
  constructor() {
    this.redis = new Redis(process.env.REDIS_URL);
    this.initializeRateLimits();
  }
  
  private initializeRateLimits() {
    // å®šä¹‰ä¸åŒAPIçš„é™æµè§„åˆ™
    this.limits.set('/api/auth/login', {
      windowMs: 15 * 60 * 1000, // 15åˆ†é’Ÿ
      maxRequests: 5,            // æœ€å¤š5æ¬¡å°è¯•
      blockDuration: 30 * 60 * 1000 // å°ç¦30åˆ†é’Ÿ
    });
    
    this.limits.set('/api/cad/analyze', {
      windowMs: 60 * 1000,       // 1åˆ†é’Ÿ
      maxRequests: 10,           // æœ€å¤š10æ¬¡è¯·æ±‚
      blockDuration: 5 * 60 * 1000 // å°ç¦5åˆ†é’Ÿ
    });
    
    this.limits.set('/api/poster/generate', {
      windowMs: 60 * 1000,       // 1åˆ†é’Ÿ
      maxRequests: 5,            // æœ€å¤š5æ¬¡è¯·æ±‚
      blockDuration: 10 * 60 * 1000 // å°ç¦10åˆ†é’Ÿ
    });
  }
  
  async checkRateLimit(clientId: string, endpoint: string): Promise<RateLimitResult> {
    const limit = this.limits.get(endpoint) || this.getDefaultLimit();
    const key = `rate_limit:${clientId}:${endpoint}`;
    const blockKey = `blocked:${clientId}:${endpoint}`;
    
    // æ£€æŸ¥æ˜¯å¦è¢«å°ç¦
    const isBlocked = await this.redis.get(blockKey);
    if (isBlocked) {
      return {
        allowed: false,
        remaining: 0,
        resetTime: parseInt(isBlocked),
        blocked: true
      };
    }
    
    // è·å–å½“å‰è¯·æ±‚è®¡æ•°
    const current = await this.redis.incr(key);
    
    if (current === 1) {
      // è®¾ç½®è¿‡æœŸæ—¶é—´
      await this.redis.expire(key, Math.ceil(limit.windowMs / 1000));
    }
    
    if (current > limit.maxRequests) {
      // è§¦å‘é™æµï¼Œè®¾ç½®å°ç¦
      const blockUntil = Date.now() + limit.blockDuration;
      await this.redis.setex(blockKey, Math.ceil(limit.blockDuration / 1000), blockUntil.toString());
      
      // è®°å½•å®‰å…¨äº‹ä»¶
      await this.logSecurityEvent(clientId, 'rate_limit_exceeded', {
        endpoint,
        requests: current,
        limit: limit.maxRequests,
        timestamp: new Date().toISOString()
      });
      
      return {
        allowed: false,
        remaining: 0,
        resetTime: blockUntil,
        blocked: true
      };
    }
    
    const ttl = await this.redis.ttl(key);
    const resetTime = Date.now() + (ttl * 1000);
    
    return {
      allowed: true,
      remaining: limit.maxRequests - current,
      resetTime,
      blocked: false
    };
  }
  
  // é™æµä¸­é—´ä»¶
  rateLimitMiddleware() {
    return async (req: Request, res: Response, next: NextFunction) => {
      const clientId = this.getClientId(req);
      const endpoint = req.route?.path || req.path;
      
      const result = await this.checkRateLimit(clientId, endpoint);
      
      // è®¾ç½®å“åº”å¤´
      res.set({
        'X-RateLimit-Remaining': result.remaining.toString(),
        'X-RateLimit-Reset': new Date(result.resetTime).toISOString()
      });
      
      if (!result.allowed) {
        return res.status(429).json({
          error: 'Too Many Requests',
          message: result.blocked ? 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œå·²è¢«ä¸´æ—¶å°ç¦' : 'è¯·æ±‚é¢‘ç‡è¶…é™',
          resetTime: result.resetTime
        });
      }
      
      next();
    };
  }
  
  private getClientId(req: Request): string {
    // ä¼˜å…ˆä½¿ç”¨ç”¨æˆ·IDï¼Œå…¶æ¬¡ä½¿ç”¨IPåœ°å€
    return req.user?.id || req.ip || 'anonymous';
  }
}
```

### B. SQLæ³¨å…¥é˜²æŠ¤

```typescript
// SQLæ³¨å…¥é˜²æŠ¤
class SQLInjectionProtection {
  private suspiciousPatterns = [
    /('|(\-\-)|(;)|(\||\|)|(\*|\*))/i,
    /(union|select|insert|delete|update|drop|create|alter|exec|execute)/i,
    /(script|javascript|vbscript|onload|onerror|onclick)/i,
    /(\<|\>|\&|\#)/i
  ];
  
  // æ£€æµ‹SQLæ³¨å…¥
  detectSQLInjection(input: string): boolean {
    if (!input || typeof input !== 'string') {
      return false;
    }
    
    return this.suspiciousPatterns.some(pattern => pattern.test(input));
  }
  
  // å‚æ•°åŒ–æŸ¥è¯¢åŒ…è£…å™¨
  async safeQuery(query: string, params: any[]): Promise<any> {
    // æ£€æŸ¥æŸ¥è¯¢è¯­å¥
    if (this.detectSQLInjection(query)) {
      throw new Error('æ£€æµ‹åˆ°æ½œåœ¨çš„SQLæ³¨å…¥æ”»å‡»');
    }
    
    // æ£€æŸ¥å‚æ•°
    for (const param of params) {
      if (typeof param === 'string' && this.detectSQLInjection(param)) {
        throw new Error('æ£€æµ‹åˆ°æ½œåœ¨çš„SQLæ³¨å…¥æ”»å‡»');
      }
    }
    
    // æ‰§è¡Œå‚æ•°åŒ–æŸ¥è¯¢
    return await this.database.query(query, params);
  }
  
  // è¾“å…¥éªŒè¯ä¸­é—´ä»¶
  validateInput() {
    return (req: Request, res: Response, next: NextFunction) => {
      const checkObject = (obj: any, path = '') => {
        for (const [key, value] of Object.entries(obj)) {
          const currentPath = path ? `${path}.${key}` : key;
          
          if (typeof value === 'string' && this.detectSQLInjection(value)) {
            // è®°å½•å®‰å…¨äº‹ä»¶
            this.logSecurityEvent(req.user?.id || req.ip, 'sql_injection_attempt', {
              path: currentPath,
              value,
              userAgent: req.get('User-Agent'),
              timestamp: new Date().toISOString()
            });
            
            return res.status(400).json({
              error: 'Invalid Input',
              message: 'è¾“å…¥åŒ…å«éæ³•å­—ç¬¦'
            });
          }
          
          if (typeof value === 'object' && value !== null) {
            checkObject(value, currentPath);
          }
        }
      };
      
      // æ£€æŸ¥è¯·æ±‚ä½“
      if (req.body) {
        checkObject(req.body);
      }
      
      // æ£€æŸ¥æŸ¥è¯¢å‚æ•°
      if (req.query) {
        checkObject(req.query);
      }
      
      next();
    };
  }
}
```

## ğŸ“ æ–‡ä»¶ä¸Šä¼ å®‰å…¨

### A. æ–‡ä»¶ç±»å‹å’Œå†…å®¹éªŒè¯

```typescript
// æ–‡ä»¶ä¸Šä¼ å®‰å…¨æ£€æŸ¥
class FileUploadSecurity {
  private allowedMimeTypes = new Set([
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/webp',
    'application/pdf',
    'application/dwg',
    'application/dxf'
  ]);
  
  private maxFileSize = 50 * 1024 * 1024; // 50MB
  private virusScanner: VirusScanner;
  
  constructor() {
    this.virusScanner = new VirusScanner();
  }
  
  async validateFile(file: Express.Multer.File): Promise<FileValidationResult> {
    const results = {
      valid: true,
      errors: [] as string[],
      warnings: [] as string[]
    };
    
    // 1. æ–‡ä»¶å¤§å°æ£€æŸ¥
    if (file.size > this.maxFileSize) {
      results.valid = false;
      results.errors.push(`æ–‡ä»¶å¤§å°è¶…è¿‡é™åˆ¶ (${this.maxFileSize / 1024 / 1024}MB)`);
    }
    
    // 2. MIMEç±»å‹æ£€æŸ¥
    if (!this.allowedMimeTypes.has(file.mimetype)) {
      results.valid = false;
      results.errors.push(`ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: ${file.mimetype}`);
    }
    
    // 3. æ–‡ä»¶æ‰©å±•åæ£€æŸ¥
    const extension = path.extname(file.originalname).toLowerCase();
    if (!this.isAllowedExtension(extension)) {
      results.valid = false;
      results.errors.push(`ä¸æ”¯æŒçš„æ–‡ä»¶æ‰©å±•å: ${extension}`);
    }
    
    // 4. æ–‡ä»¶å†…å®¹æ£€æŸ¥
    const contentValidation = await this.validateFileContent(file);
    if (!contentValidation.valid) {
      results.valid = false;
      results.errors.push(...contentValidation.errors);
    }
    
    // 5. ç—…æ¯’æ‰«æ
    const virusScanResult = await this.virusScanner.scan(file.buffer);
    if (virusScanResult.infected) {
      results.valid = false;
      results.errors.push('æ–‡ä»¶åŒ…å«æ¶æ„ä»£ç ');
      
      // è®°å½•å®‰å…¨äº‹ä»¶
      await this.logSecurityEvent('file_upload', 'virus_detected', {
        filename: file.originalname,
        mimetype: file.mimetype,
        size: file.size,
        virusName: virusScanResult.virusName
      });
    }
    
    return results;
  }
  
  private async validateFileContent(file: Express.Multer.File): Promise<FileValidationResult> {
    const results = { valid: true, errors: [] as string[] };
    
    try {
      // æ£€æŸ¥æ–‡ä»¶å¤´éƒ¨é­”æ•°
      const fileSignature = file.buffer.slice(0, 16).toString('hex');
      
      if (file.mimetype.startsWith('image/')) {
        if (!this.isValidImageSignature(fileSignature, file.mimetype)) {
          results.valid = false;
          results.errors.push('æ–‡ä»¶å†…å®¹ä¸å£°æ˜çš„ç±»å‹ä¸åŒ¹é…');
        }
      }
      
      // æ£€æŸ¥åµŒå…¥çš„è„šæœ¬
      const content = file.buffer.toString('utf8', 0, Math.min(file.size, 1024));
      if (this.containsScript(content)) {
        results.valid = false;
        results.errors.push('æ–‡ä»¶åŒ…å«å¯æ‰§è¡Œè„šæœ¬');
      }
      
    } catch (error) {
      results.valid = false;
      results.errors.push('æ–‡ä»¶å†…å®¹éªŒè¯å¤±è´¥');
    }
    
    return results;
  }
  
  private isValidImageSignature(signature: string, mimetype: string): boolean {
    const signatures = {
      'image/jpeg': ['ffd8ffe0', 'ffd8ffe1', 'ffd8ffe2'],
      'image/png': ['89504e47'],
      'image/gif': ['47494638'],
      'image/webp': ['52494646']
    };
    
    const validSignatures = signatures[mimetype] || [];
    return validSignatures.some(sig => signature.startsWith(sig));
  }
  
  private containsScript(content: string): boolean {
    const scriptPatterns = [
      /<script[^>]*>/i,
      /javascript:/i,
      /vbscript:/i,
      /on\w+\s*=/i
    ];
    
    return scriptPatterns.some(pattern => pattern.test(content));
  }
  
  // å®‰å…¨æ–‡ä»¶ä¸Šä¼ ä¸­é—´ä»¶
  secureUpload() {
    return async (req: Request, res: Response, next: NextFunction) => {
      if (!req.file && !req.files) {
        return next();
      }
      
      const files = req.files ? (Array.isArray(req.files) ? req.files : Object.values(req.files).flat()) : [req.file];
      
      for (const file of files) {
        if (file) {
          const validation = await this.validateFile(file);
          
          if (!validation.valid) {
            return res.status(400).json({
              error: 'File Validation Failed',
              details: validation.errors
            });
          }
        }
      }
      
      next();
    };
  }
}
```

## ğŸ” å®‰å…¨å®¡è®¡å’Œç›‘æ§

### A. å®‰å…¨äº‹ä»¶æ—¥å¿—

```typescript
// å®‰å…¨å®¡è®¡æœåŠ¡
class SecurityAuditService {
  private auditLogger: winston.Logger;
  private alertThresholds = new Map<string, number>();
  
  constructor() {
    this.auditLogger = winston.createLogger({
      level: 'info',
      format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
      ),
      transports: [
        new winston.transports.File({
          filename: '/var/log/security/security-audit.log',
          maxsize: 100 * 1024 * 1024, // 100MB
          maxFiles: 10
        }),
        new winston.transports.Console()
      ]
    });
    
    this.initializeAlertThresholds();
  }
  
  private initializeAlertThresholds() {
    this.alertThresholds.set('login_failed', 5);           // 5æ¬¡ç™»å½•å¤±è´¥
    this.alertThresholds.set('permission_denied', 10);     // 10æ¬¡æƒé™æ‹’ç»
    this.alertThresholds.set('sql_injection_attempt', 1);  // 1æ¬¡SQLæ³¨å…¥å°è¯•
    this.alertThresholds.set('rate_limit_exceeded', 3);    // 3æ¬¡é™æµè§¦å‘
  }
  
  async logSecurityEvent(userId: string, eventType: string, details: any) {
    const event = {
      userId,
      eventType,
      details,
      timestamp: new Date().toISOString(),
      severity: this.getEventSeverity(eventType),
      sessionId: details.sessionId,
      ipAddress: details.ipAddress,
      userAgent: details.userAgent
    };
    
    // è®°å½•åˆ°å®¡è®¡æ—¥å¿—
    this.auditLogger.info('Security Event', event);
    
    // å­˜å‚¨åˆ°æ•°æ®åº“
    await this.storeSecurityEvent(event);
    
    // æ£€æŸ¥æ˜¯å¦éœ€è¦å‘Šè­¦
    await this.checkAlertThreshold(userId, eventType);
  }
  
  private getEventSeverity(eventType: string): string {
    const severityMap = {
      'login_success': 'info',
      'login_failed': 'warning',
      'permission_denied': 'warning',
      'sql_injection_attempt': 'critical',
      'virus_detected': 'critical',
      'rate_limit_exceeded': 'warning',
      'mfa_verification_failed': 'warning',
      'password_changed': 'info',
      'account_locked': 'warning'
    };
    
    return severityMap[eventType] || 'info';
  }
  
  private async checkAlertThreshold(userId: string, eventType: string) {
    const threshold = this.alertThresholds.get(eventType);
    if (!threshold) return;
    
    const recentEvents = await this.getRecentEvents(userId, eventType, 3600000); // 1å°æ—¶å†…
    
    if (recentEvents.length >= threshold) {
      await this.sendSecurityAlert({
        userId,
        eventType,
        count: recentEvents.length,
        threshold,
        timeWindow: '1 hour'
      });
    }
  }
  
  async generateSecurityReport(startDate: Date, endDate: Date): Promise<SecurityReport> {
    const events = await this.getSecurityEvents(startDate, endDate);
    
    const report = {
      period: { start: startDate, end: endDate },
      summary: {
        totalEvents: events.length,
        criticalEvents: events.filter(e => e.severity === 'critical').length,
        warningEvents: events.filter(e => e.severity === 'warning').length,
        infoEvents: events.filter(e => e.severity === 'info').length
      },
      topEvents: this.getTopEventTypes(events),
      suspiciousUsers: await this.identifySuspiciousUsers(events),
      recommendations: this.generateRecommendations(events)
    };
    
    return report;
  }
}
```

## ğŸš€ å®æ–½è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼šèº«ä»½è®¤è¯å¼ºåŒ–ï¼ˆ2å‘¨ï¼‰
1. å¤šå› ç´ è®¤è¯å®æ–½
2. RBACæƒé™ç³»ç»Ÿéƒ¨ç½²
3. ä¼šè¯ç®¡ç†ä¼˜åŒ–

### ç¬¬äºŒé˜¶æ®µï¼šæ•°æ®å®‰å…¨ä¿æŠ¤ï¼ˆ2å‘¨ï¼‰
1. æ•°æ®åŠ å¯†å®æ–½
2. æ•°æ®è„±æ•éƒ¨ç½²
3. å¤‡ä»½åŠ å¯†é…ç½®

### ç¬¬ä¸‰é˜¶æ®µï¼šAPIå®‰å…¨é˜²æŠ¤ï¼ˆ2å‘¨ï¼‰
1. APIé™æµéƒ¨ç½²
2. è¾“å…¥éªŒè¯å¼ºåŒ–
3. SQLæ³¨å…¥é˜²æŠ¤

### ç¬¬å››é˜¶æ®µï¼šç›‘æ§å’Œå®¡è®¡ï¼ˆ1å‘¨ï¼‰
1. å®‰å…¨äº‹ä»¶ç›‘æ§
2. å®¡è®¡æ—¥å¿—ç³»ç»Ÿ
3. å‘Šè­¦æœºåˆ¶å®Œå–„

## ğŸ“ˆ é¢„æœŸæ•ˆæœ

å®Œæˆå¼ºåŒ–åé¢„æœŸå®ç°ï¼š
- ğŸ”’ é›¶å®‰å…¨æ¼æ´ç›®æ ‡
- ğŸ›¡ï¸ 100%æ•°æ®åŠ å¯†ä¿æŠ¤
- ğŸ” å¤šå› ç´ è®¤è¯è¦†ç›–ç‡100%
- ğŸ“Š å®‰å…¨äº‹ä»¶å“åº”æ—¶é—´â‰¤24å°æ—¶
- ğŸ¯ é€šè¿‡å®‰å…¨åˆè§„è®¤è¯