# ZK-Agent ç”¨æˆ·ä½“éªŒä¼˜åŒ–ç­–ç•¥

## ğŸ“‹ æ¦‚è¿°

æœ¬ç­–ç•¥æ—¨åœ¨å…¨é¢æå‡ZK-Agentå¹³å°çš„ç”¨æˆ·ä½“éªŒï¼Œé€šè¿‡ç•Œé¢ä¼˜åŒ–ã€äº¤äº’æ”¹è¿›ã€æ€§èƒ½æå‡å’Œä¸ªæ€§åŒ–å®šåˆ¶ï¼Œä¸ºç”¨æˆ·æä¾›æ›´åŠ æµç•…ã€ç›´è§‚å’Œé«˜æ•ˆçš„ä½¿ç”¨ä½“éªŒã€‚

## ğŸ¯ ä¼˜åŒ–ç›®æ ‡

### 1. ç”¨æˆ·ä½“éªŒæŒ‡æ ‡
- **é¡µé¢åŠ è½½æ—¶é—´**: â‰¤ 2ç§’
- **äº¤äº’å“åº”æ—¶é—´**: â‰¤ 300ms
- **ç”¨æˆ·æ»¡æ„åº¦**: â‰¥ 4.5/5.0
- **ä»»åŠ¡å®Œæˆç‡**: â‰¥ 95%

### 2. å¯ç”¨æ€§æŒ‡æ ‡
- **å­¦ä¹ æ›²çº¿**: æ–°ç”¨æˆ·5åˆ†é’Ÿå†…ä¸Šæ‰‹
- **é”™è¯¯ç‡**: â‰¤ 2%
- **å¸®åŠ©æ–‡æ¡£ä½¿ç”¨ç‡**: â‰¤ 10%
- **ç”¨æˆ·ç•™å­˜ç‡**: â‰¥ 85%

## ğŸ¨ ç•Œé¢è®¾è®¡ä¼˜åŒ–

### A. ç°ä»£åŒ–UIè®¾è®¡ç³»ç»Ÿ

```typescript
// è®¾è®¡ç³»ç»Ÿé…ç½®
const designSystem = {
  // é¢œè‰²ç³»ç»Ÿ
  colors: {
    primary: {
      50: '#f0f9ff',
      100: '#e0f2fe',
      500: '#0ea5e9',
      600: '#0284c7',
      700: '#0369a1',
      900: '#0c4a6e'
    },
    semantic: {
      success: '#10b981',
      warning: '#f59e0b',
      error: '#ef4444',
      info: '#3b82f6'
    },
    neutral: {
      50: '#f8fafc',
      100: '#f1f5f9',
      200: '#e2e8f0',
      500: '#64748b',
      700: '#334155',
      900: '#0f172a'
    }
  },
  
  // å­—ä½“ç³»ç»Ÿ
  typography: {
    fontFamily: {
      sans: ['Inter', 'system-ui', 'sans-serif'],
      mono: ['JetBrains Mono', 'monospace']
    },
    fontSize: {
      xs: '0.75rem',
      sm: '0.875rem',
      base: '1rem',
      lg: '1.125rem',
      xl: '1.25rem',
      '2xl': '1.5rem',
      '3xl': '1.875rem'
    },
    fontWeight: {
      normal: '400',
      medium: '500',
      semibold: '600',
      bold: '700'
    }
  },
  
  // é—´è·ç³»ç»Ÿ
  spacing: {
    xs: '0.25rem',
    sm: '0.5rem',
    md: '1rem',
    lg: '1.5rem',
    xl: '2rem',
    '2xl': '3rem'
  },
  
  // åœ†è§’ç³»ç»Ÿ
  borderRadius: {
    sm: '0.25rem',
    md: '0.375rem',
    lg: '0.5rem',
    xl: '0.75rem',
    full: '9999px'
  },
  
  // é˜´å½±ç³»ç»Ÿ
  boxShadow: {
    sm: '0 1px 2px 0 rgb(0 0 0 / 0.05)',
    md: '0 4px 6px -1px rgb(0 0 0 / 0.1)',
    lg: '0 10px 15px -3px rgb(0 0 0 / 0.1)',
    xl: '0 20px 25px -5px rgb(0 0 0 / 0.1)'
  }
};

// ä¸»é¢˜æä¾›è€…ç»„ä»¶
const ThemeProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  const themeConfig = {
    ...designSystem,
    mode: theme,
    toggleTheme
  };
  
  return (
    <ThemeContext.Provider value={themeConfig}>
      <div className={`theme-${theme}`}>
        {children}
      </div>
    </ThemeContext.Provider>
  );
};

// å“åº”å¼è®¾è®¡Hook
const useResponsive = () => {
  const [screenSize, setScreenSize] = useState<ScreenSize>('desktop');
  
  useEffect(() => {
    const handleResize = () => {
      const width = window.innerWidth;
      
      if (width < 640) {
        setScreenSize('mobile');
      } else if (width < 1024) {
        setScreenSize('tablet');
      } else {
        setScreenSize('desktop');
      }
    };
    
    handleResize();
    window.addEventListener('resize', handleResize);
    
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return {
    screenSize,
    isMobile: screenSize === 'mobile',
    isTablet: screenSize === 'tablet',
    isDesktop: screenSize === 'desktop'
  };
};

type ScreenSize = 'mobile' | 'tablet' | 'desktop';
```

### B. ç»„ä»¶åº“ä¼˜åŒ–

```typescript
// ä¼˜åŒ–çš„æŒ‰é’®ç»„ä»¶
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'outline' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
  loading?: boolean;
  disabled?: boolean;
  icon?: React.ReactNode;
  children: React.ReactNode;
  onClick?: () => void;
}

const Button: React.FC<ButtonProps> = ({
  variant = 'primary',
  size = 'md',
  loading = false,
  disabled = false,
  icon,
  children,
  onClick
}) => {
  const { colors, spacing, borderRadius } = useTheme();
  
  const baseStyles = {
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center',
    gap: spacing.sm,
    fontWeight: '500',
    borderRadius: borderRadius.md,
    border: 'none',
    cursor: disabled || loading ? 'not-allowed' : 'pointer',
    transition: 'all 0.2s ease-in-out',
    outline: 'none',
    position: 'relative'
  };
  
  const variantStyles = {
    primary: {
      backgroundColor: colors.primary[600],
      color: 'white',
      '&:hover': {
        backgroundColor: colors.primary[700]
      },
      '&:focus': {
        boxShadow: `0 0 0 3px ${colors.primary[200]}`
      }
    },
    secondary: {
      backgroundColor: colors.neutral[100],
      color: colors.neutral[700],
      '&:hover': {
        backgroundColor: colors.neutral[200]
      }
    },
    outline: {
      backgroundColor: 'transparent',
      color: colors.primary[600],
      border: `1px solid ${colors.primary[600]}`,
      '&:hover': {
        backgroundColor: colors.primary[50]
      }
    },
    ghost: {
      backgroundColor: 'transparent',
      color: colors.neutral[700],
      '&:hover': {
        backgroundColor: colors.neutral[100]
      }
    }
  };
  
  const sizeStyles = {
    sm: {
      padding: `${spacing.xs} ${spacing.sm}`,
      fontSize: '0.875rem'
    },
    md: {
      padding: `${spacing.sm} ${spacing.md}`,
      fontSize: '1rem'
    },
    lg: {
      padding: `${spacing.md} ${spacing.lg}`,
      fontSize: '1.125rem'
    }
  };
  
  return (
    <button
      style={{
        ...baseStyles,
        ...variantStyles[variant],
        ...sizeStyles[size],
        opacity: disabled ? 0.6 : 1
      }}
      disabled={disabled || loading}
      onClick={onClick}
      aria-label={typeof children === 'string' ? children : undefined}
    >
      {loading && (
        <div className="animate-spin">
          <LoadingIcon size={16} />
        </div>
      )}
      {icon && !loading && icon}
      {children}
    </button>
  );
};

// æ™ºèƒ½è¾“å…¥ç»„ä»¶
interface SmartInputProps {
  label: string;
  type?: 'text' | 'email' | 'password' | 'number';
  placeholder?: string;
  value: string;
  onChange: (value: string) => void;
  validation?: (value: string) => string | null;
  suggestions?: string[];
  autoComplete?: boolean;
}

const SmartInput: React.FC<SmartInputProps> = ({
  label,
  type = 'text',
  placeholder,
  value,
  onChange,
  validation,
  suggestions = [],
  autoComplete = false
}) => {
  const [focused, setFocused] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const [filteredSuggestions, setFilteredSuggestions] = useState<string[]>([]);
  
  const { colors, spacing, borderRadius } = useTheme();
  
  useEffect(() => {
    if (validation) {
      const validationError = validation(value);
      setError(validationError);
    }
  }, [value, validation]);
  
  useEffect(() => {
    if (autoComplete && value && suggestions.length > 0) {
      const filtered = suggestions.filter(suggestion =>
        suggestion.toLowerCase().includes(value.toLowerCase())
      );
      setFilteredSuggestions(filtered);
      setShowSuggestions(filtered.length > 0 && focused);
    } else {
      setShowSuggestions(false);
    }
  }, [value, suggestions, autoComplete, focused]);
  
  const inputStyles = {
    width: '100%',
    padding: spacing.sm,
    border: `1px solid ${error ? colors.semantic.error : focused ? colors.primary[500] : colors.neutral[200]}`,
    borderRadius: borderRadius.md,
    fontSize: '1rem',
    outline: 'none',
    transition: 'all 0.2s ease-in-out',
    backgroundColor: 'white'
  };
  
  return (
    <div style={{ position: 'relative', marginBottom: spacing.md }}>
      <label
        style={{
          display: 'block',
          marginBottom: spacing.xs,
          fontSize: '0.875rem',
          fontWeight: '500',
          color: colors.neutral[700]
        }}
      >
        {label}
      </label>
      
      <input
        type={type}
        placeholder={placeholder}
        value={value}
        onChange={(e) => onChange(e.target.value)}
        onFocus={() => setFocused(true)}
        onBlur={() => {
          setFocused(false);
          setTimeout(() => setShowSuggestions(false), 200);
        }}
        style={inputStyles}
        aria-invalid={!!error}
        aria-describedby={error ? `${label}-error` : undefined}
      />
      
      {showSuggestions && (
        <div
          style={{
            position: 'absolute',
            top: '100%',
            left: 0,
            right: 0,
            backgroundColor: 'white',
            border: `1px solid ${colors.neutral[200]}`,
            borderRadius: borderRadius.md,
            boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1)',
            zIndex: 10,
            maxHeight: '200px',
            overflowY: 'auto'
          }}
        >
          {filteredSuggestions.map((suggestion, index) => (
            <div
              key={index}
              style={{
                padding: spacing.sm,
                cursor: 'pointer',
                borderBottom: index < filteredSuggestions.length - 1 ? `1px solid ${colors.neutral[100]}` : 'none'
              }}
              onClick={() => {
                onChange(suggestion);
                setShowSuggestions(false);
              }}
              onMouseEnter={(e) => {
                e.currentTarget.style.backgroundColor = colors.neutral[50];
              }}
              onMouseLeave={(e) => {
                e.currentTarget.style.backgroundColor = 'white';
              }}
            >
              {suggestion}
            </div>
          ))}
        </div>
      )}
      
      {error && (
        <div
          id={`${label}-error`}
          style={{
            marginTop: spacing.xs,
            fontSize: '0.75rem',
            color: colors.semantic.error
          }}
        >
          {error}
        </div>
      )}
    </div>
  );
};
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### A. å‰ç«¯æ€§èƒ½ä¼˜åŒ–

```typescript
// è™šæ‹Ÿæ»šåŠ¨ç»„ä»¶
interface VirtualScrollProps<T> {
  items: T[];
  itemHeight: number;
  containerHeight: number;
  renderItem: (item: T, index: number) => React.ReactNode;
  overscan?: number;
}

const VirtualScroll = <T,>({
  items,
  itemHeight,
  containerHeight,
  renderItem,
  overscan = 5
}: VirtualScrollProps<T>) => {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);
  
  const visibleCount = Math.ceil(containerHeight / itemHeight);
  const startIndex = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);
  const endIndex = Math.min(items.length - 1, startIndex + visibleCount + overscan * 2);
  
  const visibleItems = items.slice(startIndex, endIndex + 1);
  const totalHeight = items.length * itemHeight;
  const offsetY = startIndex * itemHeight;
  
  const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
    setScrollTop(e.currentTarget.scrollTop);
  }, []);
  
  return (
    <div
      ref={containerRef}
      style={{
        height: containerHeight,
        overflow: 'auto'
      }}
      onScroll={handleScroll}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div
          style={{
            transform: `translateY(${offsetY}px)`,
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0
          }}
        >
          {visibleItems.map((item, index) => (
            <div
              key={startIndex + index}
              style={{ height: itemHeight }}
            >
              {renderItem(item, startIndex + index)}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

// å›¾ç‰‡æ‡’åŠ è½½ç»„ä»¶
interface LazyImageProps {
  src: string;
  alt: string;
  placeholder?: string;
  className?: string;
  onLoad?: () => void;
  onError?: () => void;
}

const LazyImage: React.FC<LazyImageProps> = ({
  src,
  alt,
  placeholder,
  className,
  onLoad,
  onError
}) => {
  const [loaded, setLoaded] = useState(false);
  const [error, setError] = useState(false);
  const [inView, setInView] = useState(false);
  const imgRef = useRef<HTMLImageElement>(null);
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setInView(true);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, []);
  
  const handleLoad = () => {
    setLoaded(true);
    onLoad?.();
  };
  
  const handleError = () => {
    setError(true);
    onError?.();
  };
  
  return (
    <div ref={imgRef} className={className}>
      {inView && (
        <>
          {!loaded && !error && placeholder && (
            <img
              src={placeholder}
              alt={alt}
              style={{
                filter: 'blur(5px)',
                transition: 'filter 0.3s ease'
              }}
            />
          )}
          
          <img
            src={src}
            alt={alt}
            onLoad={handleLoad}
            onError={handleError}
            style={{
              opacity: loaded ? 1 : 0,
              transition: 'opacity 0.3s ease',
              position: placeholder && !loaded ? 'absolute' : 'static',
              top: 0,
              left: 0,
              width: '100%',
              height: '100%',
              objectFit: 'cover'
            }}
          />
          
          {error && (
            <div
              style={{
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                backgroundColor: '#f3f4f6',
                color: '#6b7280',
                fontSize: '0.875rem'
              }}
            >
              å›¾ç‰‡åŠ è½½å¤±è´¥
            </div>
          )}
        </>
      )}
    </div>
  );
};

// ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
const LazyCADAnalyzer = lazy(() => import('./components/CADAnalyzer'));
const LazyPosterGenerator = lazy(() => import('./components/PosterGenerator'));
const LazyChatInterface = lazy(() => import('./components/ChatInterface'));

// è·¯ç”±é…ç½®
const AppRouter: React.FC = () => {
  return (
    <Router>
      <Suspense fallback={<LoadingSpinner />}>
        <Routes>
          <Route path="/" element={<Dashboard />} />
          <Route path="/cad" element={<LazyCADAnalyzer />} />
          <Route path="/poster" element={<LazyPosterGenerator />} />
          <Route path="/chat" element={<LazyChatInterface />} />
        </Routes>
      </Suspense>
    </Router>
  );
};

// æ€§èƒ½ç›‘æ§Hook
const usePerformanceMonitor = () => {
  const [metrics, setMetrics] = useState<PerformanceMetrics | null>(null);
  
  useEffect(() => {
    // ç›‘æ§é¡µé¢åŠ è½½æ€§èƒ½
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      
      entries.forEach((entry) => {
        if (entry.entryType === 'navigation') {
          const navEntry = entry as PerformanceNavigationTiming;
          
          setMetrics({
            loadTime: navEntry.loadEventEnd - navEntry.loadEventStart,
            domContentLoaded: navEntry.domContentLoadedEventEnd - navEntry.domContentLoadedEventStart,
            firstPaint: navEntry.responseEnd - navEntry.requestStart,
            timeToInteractive: navEntry.loadEventEnd - navEntry.fetchStart
          });
        }
      });
    });
    
    observer.observe({ entryTypes: ['navigation', 'paint', 'largest-contentful-paint'] });
    
    return () => observer.disconnect();
  }, []);
  
  return metrics;
};

interface PerformanceMetrics {
  loadTime: number;
  domContentLoaded: number;
  firstPaint: number;
  timeToInteractive: number;
}
```

### B. ç¼“å­˜ç­–ç•¥ä¼˜åŒ–

```typescript
// æ™ºèƒ½ç¼“å­˜ç®¡ç†
class CacheManager {
  private cache = new Map<string, CacheEntry>();
  private maxSize = 100;
  private ttl = 5 * 60 * 1000; // 5åˆ†é’Ÿ
  
  // è®¾ç½®ç¼“å­˜
  set<T>(key: string, value: T, customTTL?: number): void {
    const expiry = Date.now() + (customTTL || this.ttl);
    
    // å¦‚æœç¼“å­˜å·²æ»¡ï¼Œåˆ é™¤æœ€æ—§çš„æ¡ç›®
    if (this.cache.size >= this.maxSize) {
      const oldestKey = this.cache.keys().next().value;
      this.cache.delete(oldestKey);
    }
    
    this.cache.set(key, {
      value,
      expiry,
      accessCount: 0,
      lastAccess: Date.now()
    });
  }
  
  // è·å–ç¼“å­˜
  get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    
    if (!entry) {
      return null;
    }
    
    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if (Date.now() > entry.expiry) {
      this.cache.delete(key);
      return null;
    }
    
    // æ›´æ–°è®¿é—®ç»Ÿè®¡
    entry.accessCount++;
    entry.lastAccess = Date.now();
    
    return entry.value as T;
  }
  
  // é¢„åŠ è½½æ•°æ®
  async preload(keys: string[], fetcher: (key: string) => Promise<any>): Promise<void> {
    const promises = keys.map(async (key) => {
      if (!this.has(key)) {
        try {
          const value = await fetcher(key);
          this.set(key, value);
        } catch (error) {
          console.error(`é¢„åŠ è½½å¤±è´¥: ${key}`, error);
        }
      }
    });
    
    await Promise.allSettled(promises);
  }
  
  // æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨
  has(key: string): boolean {
    const entry = this.cache.get(key);
    return entry !== undefined && Date.now() <= entry.expiry;
  }
  
  // æ¸…ç†è¿‡æœŸç¼“å­˜
  cleanup(): void {
    const now = Date.now();
    
    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expiry) {
        this.cache.delete(key);
      }
    }
  }
  
  // è·å–ç¼“å­˜ç»Ÿè®¡
  getStats(): CacheStats {
    const entries = Array.from(this.cache.values());
    
    return {
      size: this.cache.size,
      hitRate: this.calculateHitRate(),
      averageAccessCount: entries.reduce((sum, entry) => sum + entry.accessCount, 0) / entries.length,
      oldestEntry: Math.min(...entries.map(entry => entry.lastAccess)),
      newestEntry: Math.max(...entries.map(entry => entry.lastAccess))
    };
  }
  
  private calculateHitRate(): number {
    // è¿™é‡Œéœ€è¦è·Ÿè¸ªå‘½ä¸­å’Œæœªå‘½ä¸­çš„æ¬¡æ•°
    // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥ç»´æŠ¤è¿™äº›ç»Ÿè®¡ä¿¡æ¯
    return 0.85; // ç¤ºä¾‹å€¼
  }
}

interface CacheEntry {
  value: any;
  expiry: number;
  accessCount: number;
  lastAccess: number;
}

interface CacheStats {
  size: number;
  hitRate: number;
  averageAccessCount: number;
  oldestEntry: number;
  newestEntry: number;
}

// ç¼“å­˜Hook
const useCache = () => {
  const cacheManager = useMemo(() => new CacheManager(), []);
  
  const cachedFetch = useCallback(async <T>(
    key: string,
    fetcher: () => Promise<T>,
    ttl?: number
  ): Promise<T> => {
    // å…ˆå°è¯•ä»ç¼“å­˜è·å–
    const cached = cacheManager.get<T>(key);
    if (cached !== null) {
      return cached;
    }
    
    // ç¼“å­˜æœªå‘½ä¸­ï¼Œæ‰§è¡Œè·å–æ“ä½œ
    const value = await fetcher();
    cacheManager.set(key, value, ttl);
    
    return value;
  }, [cacheManager]);
  
  return {
    cachedFetch,
    cache: cacheManager
  };
};
```

## ğŸ¯ äº¤äº’ä½“éªŒä¼˜åŒ–

### A. æ™ºèƒ½å¼•å¯¼ç³»ç»Ÿ

```typescript
// ç”¨æˆ·å¼•å¯¼ç»„ä»¶
interface TourStep {
  target: string;
  title: string;
  content: string;
  position?: 'top' | 'bottom' | 'left' | 'right';
  action?: () => void;
}

interface UserTourProps {
  steps: TourStep[];
  isOpen: boolean;
  onClose: () => void;
  onComplete: () => void;
}

const UserTour: React.FC<UserTourProps> = ({
  steps,
  isOpen,
  onClose,
  onComplete
}) => {
  const [currentStep, setCurrentStep] = useState(0);
  const [targetElement, setTargetElement] = useState<HTMLElement | null>(null);
  
  useEffect(() => {
    if (isOpen && steps[currentStep]) {
      const element = document.querySelector(steps[currentStep].target) as HTMLElement;
      setTargetElement(element);
      
      if (element) {
        // æ»šåŠ¨åˆ°ç›®æ ‡å…ƒç´ 
        element.scrollIntoView({
          behavior: 'smooth',
          block: 'center'
        });
        
        // é«˜äº®ç›®æ ‡å…ƒç´ 
        element.style.position = 'relative';
        element.style.zIndex = '1001';
        element.style.boxShadow = '0 0 0 4px rgba(59, 130, 246, 0.5)';
        element.style.borderRadius = '8px';
      }
    }
    
    return () => {
      if (targetElement) {
        targetElement.style.position = '';
        targetElement.style.zIndex = '';
        targetElement.style.boxShadow = '';
        targetElement.style.borderRadius = '';
      }
    };
  }, [currentStep, isOpen, steps, targetElement]);
  
  const nextStep = () => {
    if (steps[currentStep].action) {
      steps[currentStep].action!();
    }
    
    if (currentStep < steps.length - 1) {
      setCurrentStep(currentStep + 1);
    } else {
      onComplete();
    }
  };
  
  const prevStep = () => {
    if (currentStep > 0) {
      setCurrentStep(currentStep - 1);
    }
  };
  
  if (!isOpen || !steps[currentStep] || !targetElement) {
    return null;
  }
  
  const step = steps[currentStep];
  const rect = targetElement.getBoundingClientRect();
  
  // è®¡ç®—æç¤ºæ¡†ä½ç½®
  const getTooltipPosition = () => {
    const position = step.position || 'bottom';
    
    switch (position) {
      case 'top':
        return {
          top: rect.top - 10,
          left: rect.left + rect.width / 2,
          transform: 'translate(-50%, -100%)'
        };
      case 'bottom':
        return {
          top: rect.bottom + 10,
          left: rect.left + rect.width / 2,
          transform: 'translate(-50%, 0)'
        };
      case 'left':
        return {
          top: rect.top + rect.height / 2,
          left: rect.left - 10,
          transform: 'translate(-100%, -50%)'
        };
      case 'right':
        return {
          top: rect.top + rect.height / 2,
          left: rect.right + 10,
          transform: 'translate(0, -50%)'
        };
      default:
        return {
          top: rect.bottom + 10,
          left: rect.left + rect.width / 2,
          transform: 'translate(-50%, 0)'
        };
    }
  };
  
  return (
    <>
      {/* é®ç½©å±‚ */}
      <div
        style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundColor: 'rgba(0, 0, 0, 0.5)',
          zIndex: 1000
        }}
        onClick={onClose}
      />
      
      {/* æç¤ºæ¡† */}
      <div
        style={{
          position: 'fixed',
          ...getTooltipPosition(),
          backgroundColor: 'white',
          padding: '16px',
          borderRadius: '8px',
          boxShadow: '0 10px 15px -3px rgb(0 0 0 / 0.1)',
          maxWidth: '300px',
          zIndex: 1002
        }}
      >
        <h3 style={{ margin: '0 0 8px 0', fontSize: '1.125rem', fontWeight: '600' }}>
          {step.title}
        </h3>
        
        <p style={{ margin: '0 0 16px 0', color: '#6b7280', lineHeight: '1.5' }}>
          {step.content}
        </p>
        
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
          <span style={{ fontSize: '0.875rem', color: '#9ca3af' }}>
            {currentStep + 1} / {steps.length}
          </span>
          
          <div style={{ display: 'flex', gap: '8px' }}>
            {currentStep > 0 && (
              <Button variant="outline" size="sm" onClick={prevStep}>
                ä¸Šä¸€æ­¥
              </Button>
            )}
            
            <Button size="sm" onClick={nextStep}>
              {currentStep < steps.length - 1 ? 'ä¸‹ä¸€æ­¥' : 'å®Œæˆ'}
            </Button>
          </div>
        </div>
      </div>
    </>
  );
};

// æ™ºèƒ½æç¤ºç³»ç»Ÿ
const useSmartHints = () => {
  const [hints, setHints] = useState<SmartHint[]>([]);
  const [userBehavior, setUserBehavior] = useState<UserBehavior>({
    clickCount: 0,
    timeSpent: 0,
    completedActions: [],
    strugglingAreas: []
  });
  
  // åˆ†æç”¨æˆ·è¡Œä¸ºå¹¶ç”Ÿæˆæç¤º
  const analyzeAndGenerateHints = useCallback(() => {
    const newHints: SmartHint[] = [];
    
    // å¦‚æœç”¨æˆ·åœ¨æŸä¸ªåŒºåŸŸåœç•™æ—¶é—´è¿‡é•¿
    if (userBehavior.timeSpent > 30000 && userBehavior.clickCount < 3) {
      newHints.push({
        id: 'help-navigation',
        type: 'navigation',
        title: 'éœ€è¦å¸®åŠ©å—ï¼Ÿ',
        content: 'çœ‹èµ·æ¥æ‚¨å¯èƒ½éœ€è¦ä¸€äº›æŒ‡å¯¼ã€‚ç‚¹å‡»å³ä¸Šè§’çš„å¸®åŠ©æŒ‰é’®æŸ¥çœ‹æ•™ç¨‹ã€‚',
        priority: 'high',
        trigger: 'time_based'
      });
    }
    
    // å¦‚æœç”¨æˆ·å¤šæ¬¡ç‚¹å‡»åŒä¸€ä¸ªåŒºåŸŸ
    if (userBehavior.clickCount > 5) {
      newHints.push({
        id: 'feature-explanation',
        type: 'feature',
        title: 'åŠŸèƒ½è¯´æ˜',
        content: 'è¿™ä¸ªåŠŸèƒ½å¯ä»¥å¸®æ‚¨å¿«é€Ÿå®Œæˆä»»åŠ¡ã€‚æ‚¨å¯ä»¥å°è¯•æ‹–æ‹½æ–‡ä»¶æˆ–ç‚¹å‡»ä¸Šä¼ æŒ‰é’®ã€‚',
        priority: 'medium',
        trigger: 'behavior_based'
      });
    }
    
    setHints(newHints);
  }, [userBehavior]);
  
  // è·Ÿè¸ªç”¨æˆ·è¡Œä¸º
  const trackUserBehavior = useCallback((action: string, area: string) => {
    setUserBehavior(prev => ({
      ...prev,
      clickCount: prev.clickCount + 1,
      completedActions: [...prev.completedActions, action],
      strugglingAreas: area ? [...prev.strugglingAreas, area] : prev.strugglingAreas
    }));
  }, []);
  
  useEffect(() => {
    const timer = setInterval(() => {
      setUserBehavior(prev => ({
        ...prev,
        timeSpent: prev.timeSpent + 1000
      }));
    }, 1000);
    
    return () => clearInterval(timer);
  }, []);
  
  useEffect(() => {
    analyzeAndGenerateHints();
  }, [analyzeAndGenerateHints]);
  
  return {
    hints,
    trackUserBehavior,
    dismissHint: (hintId: string) => {
      setHints(prev => prev.filter(hint => hint.id !== hintId));
    }
  };
};

interface SmartHint {
  id: string;
  type: 'navigation' | 'feature' | 'warning' | 'success';
  title: string;
  content: string;
  priority: 'low' | 'medium' | 'high';
  trigger: 'time_based' | 'behavior_based' | 'error_based';
}

interface UserBehavior {
  clickCount: number;
  timeSpent: number;
  completedActions: string[];
  strugglingAreas: string[];
}
```

### B. ä¸ªæ€§åŒ–å®šåˆ¶

```typescript
// ç”¨æˆ·åå¥½ç®¡ç†
class UserPreferencesManager {
  private preferences: UserPreferences;
  private storageKey = 'zk-agent-preferences';
  
  constructor() {
    this.preferences = this.loadPreferences();
  }
  
  // åŠ è½½ç”¨æˆ·åå¥½
  private loadPreferences(): UserPreferences {
    try {
      const stored = localStorage.getItem(this.storageKey);
      if (stored) {
        return { ...this.getDefaultPreferences(), ...JSON.parse(stored) };
      }
    } catch (error) {
      console.error('åŠ è½½ç”¨æˆ·åå¥½å¤±è´¥:', error);
    }
    
    return this.getDefaultPreferences();
  }
  
  // é»˜è®¤åå¥½è®¾ç½®
  private getDefaultPreferences(): UserPreferences {
    return {
      theme: 'light',
      language: 'zh-CN',
      layout: 'default',
      notifications: {
        desktop: true,
        email: false,
        sound: true
      },
      dashboard: {
        widgets: ['recent-projects', 'quick-actions', 'statistics'],
        layout: 'grid'
      },
      accessibility: {
        highContrast: false,
        largeText: false,
        reduceMotion: false
      },
      shortcuts: {
        'ctrl+n': 'new-project',
        'ctrl+s': 'save',
        'ctrl+/': 'search'
      }
    };
  }
  
  // æ›´æ–°åå¥½è®¾ç½®
  updatePreferences(updates: Partial<UserPreferences>): void {
    this.preferences = { ...this.preferences, ...updates };
    this.savePreferences();
    this.applyPreferences();
  }
  
  // ä¿å­˜åå¥½è®¾ç½®
  private savePreferences(): void {
    try {
      localStorage.setItem(this.storageKey, JSON.stringify(this.preferences));
    } catch (error) {
      console.error('ä¿å­˜ç”¨æˆ·åå¥½å¤±è´¥:', error);
    }
  }
  
  // åº”ç”¨åå¥½è®¾ç½®
  private applyPreferences(): void {
    // åº”ç”¨ä¸»é¢˜
    document.documentElement.setAttribute('data-theme', this.preferences.theme);
    
    // åº”ç”¨è¯­è¨€
    document.documentElement.setAttribute('lang', this.preferences.language);
    
    // åº”ç”¨æ— éšœç¢è®¾ç½®
    if (this.preferences.accessibility.highContrast) {
      document.documentElement.classList.add('high-contrast');
    } else {
      document.documentElement.classList.remove('high-contrast');
    }
    
    if (this.preferences.accessibility.largeText) {
      document.documentElement.classList.add('large-text');
    } else {
      document.documentElement.classList.remove('large-text');
    }
    
    if (this.preferences.accessibility.reduceMotion) {
      document.documentElement.classList.add('reduce-motion');
    } else {
      document.documentElement.classList.remove('reduce-motion');
    }
  }
  
  // è·å–å½“å‰åå¥½
  getPreferences(): UserPreferences {
    return { ...this.preferences };
  }
  
  // é‡ç½®ä¸ºé»˜è®¤è®¾ç½®
  resetToDefaults(): void {
    this.preferences = this.getDefaultPreferences();
    this.savePreferences();
    this.applyPreferences();
  }
}

interface UserPreferences {
  theme: 'light' | 'dark' | 'auto';
  language: string;
  layout: 'default' | 'compact' | 'spacious';
  notifications: {
    desktop: boolean;
    email: boolean;
    sound: boolean;
  };
  dashboard: {
    widgets: string[];
    layout: 'grid' | 'list';
  };
  accessibility: {
    highContrast: boolean;
    largeText: boolean;
    reduceMotion: boolean;
  };
  shortcuts: Record<string, string>;
}

// åå¥½è®¾ç½®Hook
const useUserPreferences = () => {
  const [preferencesManager] = useState(() => new UserPreferencesManager());
  const [preferences, setPreferences] = useState(preferencesManager.getPreferences());
  
  const updatePreferences = useCallback((updates: Partial<UserPreferences>) => {
    preferencesManager.updatePreferences(updates);
    setPreferences(preferencesManager.getPreferences());
  }, [preferencesManager]);
  
  const resetPreferences = useCallback(() => {
    preferencesManager.resetToDefaults();
    setPreferences(preferencesManager.getPreferences());
  }, [preferencesManager]);
  
  return {
    preferences,
    updatePreferences,
    resetPreferences
  };
};
```

## ğŸ“± å“åº”å¼è®¾è®¡ä¼˜åŒ–

### A. ç§»åŠ¨ç«¯é€‚é…

```typescript
// ç§»åŠ¨ç«¯ä¼˜åŒ–ç»„ä»¶
const MobileOptimizedLayout: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { isMobile, isTablet } = useResponsive();
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  
  if (isMobile) {
    return (
      <div className="mobile-layout">
        {/* ç§»åŠ¨ç«¯å¤´éƒ¨ */}
        <header className="mobile-header">
          <button
            className="menu-toggle"
            onClick={() => setIsMenuOpen(!isMenuOpen)}
            aria-label="æ‰“å¼€èœå•"
          >
            <MenuIcon />
          </button>
          
          <h1 className="app-title">ZK-Agent</h1>
          
          <button className="profile-button" aria-label="ç”¨æˆ·èµ„æ–™">
            <UserIcon />
          </button>
        </header>
        
        {/* ä¾§è¾¹èœå• */}
        <nav className={`mobile-nav ${isMenuOpen ? 'open' : ''}`}>
          <div className="nav-overlay" onClick={() => setIsMenuOpen(false)} />
          <div className="nav-content">
            <MobileNavigation onItemClick={() => setIsMenuOpen(false)} />
          </div>
        </nav>
        
        {/* ä¸»å†…å®¹åŒº */}
        <main className="mobile-main">
          {children}
        </main>
        
        {/* åº•éƒ¨å¯¼èˆª */}
        <nav className="mobile-bottom-nav">
          <BottomNavigation />
        </nav>
      </div>
    );
  }
  
  if (isTablet) {
    return (
      <div className="tablet-layout">
        <aside className="tablet-sidebar">
          <TabletNavigation />
        </aside>
        
        <div className="tablet-content">
          <header className="tablet-header">
            <TabletHeader />
          </header>
          
          <main className="tablet-main">
            {children}
          </main>
        </div>
      </div>
    );
  }
  
  // æ¡Œé¢ç«¯å¸ƒå±€
  return (
    <div className="desktop-layout">
      <aside className="desktop-sidebar">
        <DesktopNavigation />
      </aside>
      
      <div className="desktop-content">
        <header className="desktop-header">
          <DesktopHeader />
        </header>
        
        <main className="desktop-main">
          {children}
        </main>
      </div>
    </div>
  );
};

// è§¦æ‘¸æ‰‹åŠ¿æ”¯æŒ
const useTouchGestures = (element: RefObject<HTMLElement>) => {
  const [gestures, setGestures] = useState<TouchGesture | null>(null);
  
  useEffect(() => {
    if (!element.current) return;
    
    let startX = 0;
    let startY = 0;
    let startTime = 0;
    
    const handleTouchStart = (e: TouchEvent) => {
      const touch = e.touches[0];
      startX = touch.clientX;
      startY = touch.clientY;
      startTime = Date.now();
    };
    
    const handleTouchEnd = (e: TouchEvent) => {
      const touch = e.changedTouches[0];
      const endX = touch.clientX;
      const endY = touch.clientY;
      const endTime = Date.now();
      
      const deltaX = endX - startX;
      const deltaY = endY - startY;
      const deltaTime = endTime - startTime;
      
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      const velocity = distance / deltaTime;
      
      // æ£€æµ‹æ‰‹åŠ¿ç±»å‹
      if (deltaTime < 300 && distance < 10) {
        setGestures({ type: 'tap', x: endX, y: endY });
      } else if (velocity > 0.5) {
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          setGestures({
            type: deltaX > 0 ? 'swipe-right' : 'swipe-left',
            distance: Math.abs(deltaX),
            velocity
          });
        } else {
          setGestures({
            type: deltaY > 0 ? 'swipe-down' : 'swipe-up',
            distance: Math.abs(deltaY),
            velocity
          });
        }
      }
    };
    
    const el = element.current;
    el.addEventListener('touchstart', handleTouchStart, { passive: true });
    el.addEventListener('touchend', handleTouchEnd, { passive: true });
    
    return () => {
      el.removeEventListener('touchstart', handleTouchStart);
      el.removeEventListener('touchend', handleTouchEnd);
    };
  }, [element]);
  
  return gestures;
};

interface TouchGesture {
  type: 'tap' | 'swipe-left' | 'swipe-right' | 'swipe-up' | 'swipe-down';
  x?: number;
  y?: number;
  distance?: number;
  velocity?: number;
}
```

## ğŸš€ å®æ–½è®¡åˆ’

### ç¬¬ä¸€é˜¶æ®µï¼šç•Œé¢ä¼˜åŒ–ï¼ˆ2å‘¨ï¼‰
1. è®¾è®¡ç³»ç»Ÿå»ºç«‹
2. ç»„ä»¶åº“é‡æ„
3. å“åº”å¼å¸ƒå±€ä¼˜åŒ–

### ç¬¬äºŒé˜¶æ®µï¼šæ€§èƒ½ä¼˜åŒ–ï¼ˆ2å‘¨ï¼‰
1. ä»£ç åˆ†å‰²å’Œæ‡’åŠ è½½
2. ç¼“å­˜ç­–ç•¥å®æ–½
3. å›¾ç‰‡å’Œèµ„æºä¼˜åŒ–

### ç¬¬ä¸‰é˜¶æ®µï¼šäº¤äº’ä¼˜åŒ–ï¼ˆ2å‘¨ï¼‰
1. æ™ºèƒ½å¼•å¯¼ç³»ç»Ÿ
2. ä¸ªæ€§åŒ–å®šåˆ¶åŠŸèƒ½
3. ç§»åŠ¨ç«¯é€‚é…å®Œå–„

### ç¬¬å››é˜¶æ®µï¼šç”¨æˆ·åé¦ˆå’Œè¿­ä»£ï¼ˆ1å‘¨ï¼‰
1. ç”¨æˆ·æµ‹è¯•å’Œåé¦ˆæ”¶é›†
2. æ€§èƒ½ç›‘æ§å’Œåˆ†æ
3. æŒç»­ä¼˜åŒ–å’Œæ”¹è¿›

## ğŸ“ˆ é¢„æœŸæ•ˆæœ

å®Œæˆä¼˜åŒ–åé¢„æœŸå®ç°ï¼š
- âš¡ é¡µé¢åŠ è½½æ—¶é—´â‰¤2ç§’
- ğŸ¯ ç”¨æˆ·æ»¡æ„åº¦â‰¥4.5/5.0
- ğŸ“± ç§»åŠ¨ç«¯ä½“éªŒæ˜¾è‘—æå‡
- ğŸ¨ ç•Œé¢ç°ä»£åŒ–å’Œä¸€è‡´æ€§
- ğŸš€ æ•´ä½“æ€§èƒ½æå‡50%