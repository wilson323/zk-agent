{"version":3,"sources":["E:\\zk-agent\\lib\\chat\\error-retry-manager.ts"],"sourcesContent":["// @ts-nocheck\n/**\n * @file Error Retry Manager\n * @description 错误重试管理器，提供智能重试策略和错误处理\n * @author ZK-Agent Team A\n * @date 2024-12-19\n */\n\n// 错误类型枚举\nexport enum ErrorType {\n  NETWORK = 'network',\n  TIMEOUT = 'timeout',\n  RATE_LIMIT = 'rate_limit',\n  AUTH = 'auth',\n  SERVER = 'server',\n  CLIENT = 'client',\n  UNKNOWN = 'unknown'\n}\n\n// 重试策略\nexport interface RetryStrategy {\n  maxRetries: number\n  baseDelay: number\n  maxDelay: number\n  backoffMultiplier: number\n  jitter: boolean\n  retryableErrors: ErrorType[]\n}\n\n// 错误信息\nexport interface ErrorInfo {\n  type: ErrorType\n  message: string\n  code?: string | number\n  statusCode?: number\n  timestamp: Date\n  retryCount: number\n  isRetryable: boolean\n  metadata?: Record<string, any>\n}\n\n// 重试结果\nexport interface RetryResult<T> {\n  success: boolean\n  data?: T\n  error?: ErrorInfo\n  totalRetries: number\n  totalDuration: number\n  attempts: Array<{\n    attempt: number\n    error?: ErrorInfo\n    duration: number\n    timestamp: Date\n  }>\n}\n\n// 重试配置\nexport interface RetryConfig {\n  strategy?: Partial<RetryStrategy>\n  onRetry?: (error: ErrorInfo, attempt: number) => void\n  onSuccess?: (result: any, attempts: number) => void\n  onFailure?: (error: ErrorInfo, attempts: number) => void\n  shouldRetry?: (error: ErrorInfo) => boolean\n}\n\n/**\n * 错误重试管理器\n */\nexport class ErrorRetryManager {\n  private defaultStrategy: RetryStrategy = {\n    maxRetries: 3,\n      baseDelay: 1000,\n      maxDelay: 30000,\n      backoffMultiplier: 2,\n    jitter: true,\n      retryableErrors: [\n      ErrorType.NETWORK,\n      ErrorType.TIMEOUT,\n      ErrorType.RATE_LIMIT,\n      ErrorType.SERVER\n    ]\n  }\n\n  private errorStats = new Map<string, {\n    count: number\n    lastOccurred: Date\n    successRate: number\n    averageRetries: number\n  }>()\n\n  constructor(defaultStrategy?: Partial<RetryStrategy>) {\n    if (defaultStrategy) {\n      this.defaultStrategy = { ...this.defaultStrategy, ...defaultStrategy }\n    }\n  }\n\n  /**\n   * 执行带重试的异步操作\n   */\n  async executeWithRetry<T>(\n    operation: () => Promise<T>,\n    config: RetryConfig = {}\n  ): Promise<RetryResult<T>> {\n    const strategy = { ...this.defaultStrategy, ...config.strategy }\n    const startTime = Date.now()\n    const attempts: RetryResult<T>['attempts'] = []\n    \n    let lastError: ErrorInfo | undefined\n\n    for (let attempt = 0; attempt <= strategy.maxRetries; attempt++) {\n      const attemptStartTime = Date.now()\n      \n      try {\n        const result = await operation()\n        const duration = Date.now() - attemptStartTime\n        \n        attempts.push({\n          attempt: attempt + 1,\n          duration,\n          timestamp: new Date()\n        })\n\n        // 记录成功\n        if (config.onSuccess) {\n          config.onSuccess(result, attempt + 1)\n        }\n\n        // 更新统计\n        this.updateSuccessStats(operation.name || 'anonymous', attempt)\n\n        return {\n            success: true,\n          data: result,\n          totalRetries: attempt,\n          totalDuration: Date.now() - startTime,\n          attempts\n        }\n        } catch (error) {\n        const duration = Date.now() - attemptStartTime\n        const errorInfo = this.parseError(error, attempt)\n        \n        attempts.push({\n          attempt: attempt + 1,\n          error: errorInfo,\n          duration,\n          timestamp: new Date()\n        })\n\n        lastError = errorInfo\n\n        // 更新错误统计\n        this.updateErrorStats(operation.name || 'anonymous', errorInfo)\n\n          // 检查是否应该重试\n        const shouldRetry = this.shouldRetry(errorInfo, attempt, strategy, config.shouldRetry)\n        \n        if (!shouldRetry || attempt >= strategy.maxRetries) {\n          break\n        }\n\n        // 执行重试回调\n        if (config.onRetry) {\n          config.onRetry(errorInfo, attempt + 1)\n        }\n\n        // 等待重试延迟\n        const delay = this.calculateDelay(attempt, strategy)\n        await this.sleep(delay)\n      }\n    }\n\n    // 执行失败回调\n    if (config.onFailure && lastError) {\n      config.onFailure(lastError, attempts.length)\n    }\n\n    return {\n      success: false,\n      error: lastError,\n      totalRetries: attempts.length - 1,\n      totalDuration: Date.now() - startTime,\n      attempts\n    }\n  }\n\n  /**\n   * 创建重试装饰器\n   */\n  createRetryDecorator(config: RetryConfig = {}) {\n    return <T extends (...args: any[]) => Promise<any>>(\n      target: any,\n      propertyKey: string,\n      descriptor: TypedPropertyDescriptor<T>\n    ) => {\n      const originalMethod = descriptor.value!\n\n      descriptor.value = async function (this: any, ...args: any[]) {\n        const result = await this.executeWithRetry(\n          () => originalMethod.apply(this, args),\n          config\n        )\n\n        if (result.success) {\n          return result.data\n        } else {\n          throw result.error\n        }\n      } as T\n\n      return descriptor\n    }\n  }\n\n  /**\n   * 批量重试操作\n   */\n  async executeBatch<T>(\n    operations: Array<() => Promise<T>>,\n    config: RetryConfig & {\n      concurrency?: number\n      failFast?: boolean\n    } = {}\n  ): Promise<Array<RetryResult<T>>> {\n    const { concurrency = 3, failFast = false } = config\n    const results: Array<RetryResult<T>> = []\n    \n    // 分批执行\n    for (let i = 0; i < operations.length; i += concurrency) {\n      const batch = operations.slice(i, i + concurrency)\n      \n      const batchPromises = batch.map(operation => \n        this.executeWithRetry(operation, config)\n      )\n\n      const batchResults = await Promise.allSettled(batchPromises)\n      \n      for (const result of batchResults) {\n        if (result.status === 'fulfilled') {\n          results.push(result.value)\n          \n          // 如果启用快速失败且有失败，停止执行\n          if (failFast && !result.value.success) {\n            return results\n          }\n        } else {\n          // Promise被拒绝，创建失败结果\n          results.push({\n            success: false,\n            error: this.parseError(result.reason, 0),\n            totalRetries: 0,\n            totalDuration: 0,\n            attempts: []\n          })\n          \n          if (failFast) {\n            return results\n          }\n        }\n      }\n    }\n\n    return results\n  }\n\n  /**\n   * 获取错误统计\n   */\n  getErrorStats(operationName?: string) {\n    if (operationName) {\n      return this.errorStats.get(operationName)\n    }\n    \n    return Object.fromEntries(this.errorStats.entries())\n  }\n\n  /**\n   * 获取所有操作的统计信息\n   */\n  getAllStats() {\n    return this.errorStats\n  }\n\n  /**\n   * 清除错误统计\n   */\n  clearErrorStats(operationName?: string) {\n    if (operationName) {\n      this.errorStats.delete(operationName)\n    } else {\n      this.errorStats.clear()\n    }\n  }\n\n  /**\n   * 创建断路器模式\n   */\n  createCircuitBreaker(config: {\n    failureThreshold: number\n    resetTimeout: number\n    monitoringPeriod: number\n  }) {\n    let state: 'closed' | 'open' | 'half-open' = 'closed'\n    let failureCount = 0\n    let lastFailureTime = 0\n    let successCount = 0\n\n    return async <T>(operation: () => Promise<T>): Promise<T> => {\n      const now = Date.now()\n\n      // 检查是否应该重置\n      if (state === 'open' && now - lastFailureTime > config.resetTimeout) {\n        state = 'half-open'\n        successCount = 0\n      }\n\n      // 如果断路器开启，直接抛出错误\n      if (state === 'open') {\n        throw new Error('Circuit breaker is open')\n      }\n\n      try {\n        const result = await operation()\n        \n        // 成功执行\n        if (state === 'half-open') {\n          successCount++\n          if (successCount >= 3) { // 连续3次成功后关闭断路器\n            state = 'closed'\n            failureCount = 0\n          }\n        } else {\n          failureCount = 0\n        }\n\n        return result\n      } catch (error) {\n        failureCount++\n        lastFailureTime = now\n\n        if (failureCount >= config.failureThreshold) {\n          state = 'open'\n        }\n\n        throw error\n      }\n    }\n  }\n\n  // 私有方法\n\n  private parseError(error: any, retryCount: number): ErrorInfo {\n    let type = ErrorType.UNKNOWN\n    let message = 'Unknown error'\n    let code: string | number | undefined\n    let statusCode: number | undefined\n\n    if (error instanceof Error) {\n      message = error.message\n      \n      // 根据错误消息判断类型\n      if (error.message.includes('network') || error.message.includes('fetch')) {\n        type = ErrorType.NETWORK\n      } else if (error.message.includes('timeout')) {\n        type = ErrorType.TIMEOUT\n      } else if (error.message.includes('401') || error.message.includes('unauthorized')) {\n        type = ErrorType.AUTH\n      }\n    }\n\n    // 处理HTTP错误\n    if (error.response) {\n      statusCode = error.response.status\n      \n      if (statusCode && statusCode >= 400 && statusCode < 500) {\n        type = statusCode === 401 ? ErrorType.AUTH : ErrorType.CLIENT\n      } else if (statusCode && statusCode >= 500) {\n        type = ErrorType.SERVER\n      } else if (statusCode === 429) {\n        type = ErrorType.RATE_LIMIT\n      }\n    }\n\n    // 处理网络错误\n    if (error.code) {\n      code = error.code\n      \n      if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {\n        type = ErrorType.NETWORK\n      } else if (error.code === 'ETIMEDOUT') {\n        type = ErrorType.TIMEOUT\n      }\n    }\n\n    const isRetryable = this.defaultStrategy.retryableErrors.includes(type)\n\n    return {\n      type,\n      message,\n      code,\n      statusCode,\n      timestamp: new Date(),\n      retryCount,\n      isRetryable,\n      metadata: {\n        originalError: error\n      }\n    }\n  }\n\n  private shouldRetry(\n    error: ErrorInfo,\n    attempt: number,\n    strategy: RetryStrategy,\n    customShouldRetry?: (error: ErrorInfo) => boolean\n  ): boolean {\n    // 如果有自定义重试逻辑，优先使用\n    if (customShouldRetry) {\n      return customShouldRetry(error)\n    }\n\n    // 检查是否达到最大重试次数\n    if (attempt >= strategy.maxRetries) {\n      return false\n    }\n\n    // 检查错误类型是否可重试\n    return strategy.retryableErrors.includes(error.type)\n  }\n\n  private calculateDelay(attempt: number, strategy: RetryStrategy): number {\n    let delay = strategy.baseDelay * Math.pow(strategy.backoffMultiplier, attempt)\n    \n    // 限制最大延迟\n    delay = Math.min(delay, strategy.maxDelay)\n    \n    // 添加抖动\n    if (strategy.jitter) {\n      delay = delay * (0.5 + Math.random() * 0.5)\n    }\n    \n    return Math.floor(delay)\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms))\n  }\n\n  private updateErrorStats(operationName: string, error: ErrorInfo) {\n    const stats = this.errorStats.get(operationName) || {\n      count: 0,\n      lastOccurred: new Date(),\n      successRate: 1.0,\n      averageRetries: 0\n    }\n\n    stats.count++\n    stats.lastOccurred = error.timestamp\n    stats.averageRetries = (stats.averageRetries * (stats.count - 1) + error.retryCount) / stats.count\n\n    this.errorStats.set(operationName, stats)\n  }\n\n  private updateSuccessStats(operationName: string, retries: number) {\n    const stats = this.errorStats.get(operationName) || {\n      count: 0,\n      lastOccurred: new Date(),\n      successRate: 1.0,\n      averageRetries: 0\n    }\n\n    // 更新成功率（简化计算）\n    const totalOperations = stats.count + 1\n    stats.successRate = (stats.successRate * stats.count + 1) / totalOperations\n    stats.averageRetries = (stats.averageRetries * stats.count + retries) / totalOperations\n\n    this.errorStats.set(operationName, stats)\n  }\n}\n\n// 创建默认实例\nexport const errorRetryManager = new ErrorRetryManager()\n\n// 导出装饰器\nexport const retry = (config?: RetryConfig) => \n  errorRetryManager.createRetryDecorator(config)\n\n// 导出类型（避免重复导出冲突）\nexport type {\n  RetryStrategy as IRetryStrategy,\n  ErrorInfo as IErrorInfo,\n  RetryResult as IRetryResult,\n  RetryConfig as IRetryConfig\n}\n"],"names":["ErrorRetryManager","ErrorType","errorRetryManager","retry","constructor","defaultStrategy","maxRetries","baseDelay","maxDelay","backoffMultiplier","jitter","retryableErrors","errorStats","Map","executeWithRetry","operation","config","strategy","startTime","Date","now","attempts","lastError","attempt","attemptStartTime","result","duration","push","timestamp","onSuccess","updateSuccessStats","name","success","data","totalRetries","totalDuration","error","errorInfo","parseError","updateErrorStats","shouldRetry","onRetry","delay","calculateDelay","sleep","onFailure","length","createRetryDecorator","target","propertyKey","descriptor","originalMethod","value","args","apply","executeBatch","operations","concurrency","failFast","results","i","batch","slice","batchPromises","map","batchResults","Promise","allSettled","status","reason","getErrorStats","operationName","get","Object","fromEntries","entries","getAllStats","clearErrorStats","delete","clear","createCircuitBreaker","state","failureCount","lastFailureTime","successCount","resetTimeout","Error","failureThreshold","retryCount","type","message","code","statusCode","includes","response","isRetryable","metadata","originalError","customShouldRetry","Math","pow","min","random","floor","ms","resolve","setTimeout","stats","count","lastOccurred","successRate","averageRetries","set","retries","totalOperations"],"mappings":"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"}