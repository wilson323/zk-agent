83f9e601a76595a9156f15605e28da56
/**
 * 管理员API路由错误处理测试
 * 测试管理员功能端点的各种错误场景和权限控制
 */ "use strict";
// Mock dependencies
jest.mock('../../../lib/services/admin-service', ()=>({
        getSystemStats: jest.fn(),
        getUserManagement: jest.fn(),
        updateSystemConfig: jest.fn(),
        performMaintenance: jest.fn(),
        getAuditLogs: jest.fn(),
        managePermissions: jest.fn(),
        backupSystem: jest.fn(),
        restoreSystem: jest.fn()
    }));
jest.mock('../../../lib/auth/admin-auth', ()=>({
        validateAdminSession: jest.fn(),
        checkSuperAdminPermissions: jest.fn(),
        validateAdminToken: jest.fn(),
        logAdminAction: jest.fn()
    }));
jest.mock('../../../lib/storage/audit-logger', ()=>({
        logSecurityEvent: jest.fn(),
        logSystemChange: jest.fn(),
        getAuditTrail: jest.fn()
    }));
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _server = require("next/server");
const _route = require("../../../app/api/admin/route");
const _globalerrorhandler = require("../../../lib/middleware/global-error-handler");
describe('Admin API Error Handling', ()=>{
    let errorHandler;
    beforeEach(()=>{
        errorHandler = _globalerrorhandler.GlobalErrorHandler.getInstance();
        jest.clearAllMocks();
    });
    describe('Authentication and Authorization', ()=>{
        it('should handle missing admin authentication', async ()=>{
            const request = new _server.NextRequest('http://localhost:3000/api/admin/stats');
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(401);
            expect(data.error.code).toBe('AUTHENTICATION_ERROR');
            expect(data.error.message).toContain('Admin authentication required');
        });
        it('should handle invalid admin token', async ()=>{
            const { validateAdminToken } = require('../../../lib/auth/admin-auth');
            validateAdminToken.mockRejectedValue(new Error('Invalid admin token'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/stats', {
                headers: {
                    'Authorization': 'Bearer invalid-token'
                }
            });
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(401);
            expect(data.error.message).toContain('Invalid admin token');
        });
        it('should handle expired admin session', async ()=>{
            const { validateAdminSession } = require('../../../lib/auth/admin-auth');
            validateAdminSession.mockRejectedValue(new Error('Admin session expired'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/stats', {
                headers: {
                    'Authorization': 'Bearer expired-token'
                }
            });
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(401);
            expect(data.error.message).toContain('Admin session expired');
        });
        it('should handle insufficient admin permissions', async ()=>{
            const { checkSuperAdminPermissions } = require('../../../lib/auth/admin-auth');
            checkSuperAdminPermissions.mockRejectedValue(new Error('Super admin permissions required'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/system/config', {
                method: 'PUT',
                headers: {
                    'Authorization': 'Bearer admin-token'
                },
                body: JSON.stringify({
                    setting: 'value'
                })
            });
            const response = await (0, _route.PUT)(request);
            const data = await response.json();
            expect(response.status).toBe(403);
            expect(data.error.code).toBe('AUTHORIZATION_ERROR');
            expect(data.error.message).toContain('Super admin permissions required');
        });
        it('should handle role-based access control violations', async ()=>{
            const { validateAdminSession } = require('../../../lib/auth/admin-auth');
            validateAdminSession.mockResolvedValue({
                role: 'moderator',
                permissions: [
                    'read'
                ]
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/users/delete', {
                method: 'DELETE',
                headers: {
                    'Authorization': 'Bearer moderator-token'
                }
            });
            const response = await (0, _route.DELETE)(request);
            const data = await response.json();
            expect(response.status).toBe(403);
            expect(data.error.message).toContain('Insufficient permissions');
        });
    });
    describe('System Statistics Errors', ()=>{
        it('should handle database connection failure for stats', async ()=>{
            const { getSystemStats } = require('../../../lib/services/admin-service');
            getSystemStats.mockRejectedValue(new Error('Database connection failed'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/stats', {
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                }
            });
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(500);
            expect(data.error.message).toContain('Database connection failed');
        });
        it('should handle metrics collection service unavailable', async ()=>{
            const { getSystemStats } = require('../../../lib/services/admin-service');
            getSystemStats.mockRejectedValue(new Error('Metrics service unavailable'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/stats', {
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                }
            });
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(503);
            expect(data.error.message).toContain('Metrics service unavailable');
        });
        it('should handle partial stats collection failure', async ()=>{
            const { getSystemStats } = require('../../../lib/services/admin-service');
            getSystemStats.mockResolvedValue({
                users: {
                    total: 100,
                    active: 80
                },
                system: null,
                errors: [
                    'Failed to collect system metrics'
                ]
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/stats', {
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                }
            });
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(206); // Partial content
            expect(data.data.errors).toContain('Failed to collect system metrics');
        });
    });
    describe('User Management Errors', ()=>{
        it('should handle user not found for management operations', async ()=>{
            const { getUserManagement } = require('../../../lib/services/admin-service');
            getUserManagement.mockRejectedValue(new Error('User not found'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/users/nonexistent-id', {
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                }
            });
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(404);
            expect(data.error.code).toBe('NOT_FOUND');
            expect(data.error.message).toContain('User not found');
        });
        it('should handle invalid user ID format', async ()=>{
            const request = new _server.NextRequest('http://localhost:3000/api/admin/users/invalid-id-format', {
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                }
            });
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.error.message).toContain('Invalid user ID format');
        });
        it('should handle attempt to modify super admin account', async ()=>{
            const { getUserManagement } = require('../../../lib/services/admin-service');
            getUserManagement.mockRejectedValue(new Error('Cannot modify super admin account'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/users/super-admin-id', {
                method: 'PUT',
                headers: {
                    'Authorization': 'Bearer admin-token'
                },
                body: JSON.stringify({
                    role: 'user'
                })
            });
            const response = await (0, _route.PUT)(request);
            const data = await response.json();
            expect(response.status).toBe(403);
            expect(data.error.message).toContain('Cannot modify super admin account');
        });
        it('should handle bulk user operation failure', async ()=>{
            const { getUserManagement } = require('../../../lib/services/admin-service');
            getUserManagement.mockRejectedValue(new Error('Bulk operation failed: some users not found'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/users/bulk', {
                method: 'PUT',
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                },
                body: JSON.stringify({
                    userIds: [
                        'id1',
                        'id2',
                        'id3'
                    ],
                    action: 'suspend'
                })
            });
            const response = await (0, _route.PUT)(request);
            const data = await response.json();
            expect(response.status).toBe(207); // Multi-status
            expect(data.error.message).toContain('Bulk operation failed');
        });
    });
    describe('System Configuration Errors', ()=>{
        it('should handle invalid configuration format', async ()=>{
            const request = new _server.NextRequest('http://localhost:3000/api/admin/system/config', {
                method: 'PUT',
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                },
                body: JSON.stringify({
                    invalidConfig: 'value'
                })
            });
            const response = await (0, _route.PUT)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.error.code).toBe('VALIDATION_ERROR');
            expect(data.error.message).toContain('Invalid configuration format');
        });
        it('should handle configuration validation failure', async ()=>{
            const { updateSystemConfig } = require('../../../lib/services/admin-service');
            updateSystemConfig.mockRejectedValue(new Error('Configuration validation failed: invalid database URL'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/system/config', {
                method: 'PUT',
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                },
                body: JSON.stringify({
                    databaseUrl: 'invalid-url'
                })
            });
            const response = await (0, _route.PUT)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.error.message).toContain('Configuration validation failed');
        });
        it('should handle configuration backup failure', async ()=>{
            const { updateSystemConfig } = require('../../../lib/services/admin-service');
            updateSystemConfig.mockRejectedValue(new Error('Failed to backup current configuration'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/system/config', {
                method: 'PUT',
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                },
                body: JSON.stringify({
                    setting: 'value'
                })
            });
            const response = await (0, _route.PUT)(request);
            const data = await response.json();
            expect(response.status).toBe(500);
            expect(data.error.message).toContain('Failed to backup current configuration');
        });
        it('should handle configuration rollback on apply failure', async ()=>{
            const { updateSystemConfig } = require('../../../lib/services/admin-service');
            updateSystemConfig.mockRejectedValue(new Error('Configuration apply failed, rolled back to previous version'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/system/config', {
                method: 'PUT',
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                },
                body: JSON.stringify({
                    setting: 'value'
                })
            });
            const response = await (0, _route.PUT)(request);
            const data = await response.json();
            expect(response.status).toBe(500);
            expect(data.error.message).toContain('Configuration apply failed, rolled back');
        });
    });
    describe('Maintenance Operations Errors', ()=>{
        it('should handle maintenance mode activation failure', async ()=>{
            const { performMaintenance } = require('../../../lib/services/admin-service');
            performMaintenance.mockRejectedValue(new Error('Failed to activate maintenance mode'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/maintenance', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                },
                body: JSON.stringify({
                    action: 'enable',
                    reason: 'System update'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(500);
            expect(data.error.message).toContain('Failed to activate maintenance mode');
        });
        it('should handle database maintenance operation failure', async ()=>{
            const { performMaintenance } = require('../../../lib/services/admin-service');
            performMaintenance.mockRejectedValue(new Error('Database maintenance failed: table lock timeout'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/maintenance/database', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                },
                body: JSON.stringify({
                    operation: 'optimize'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(500);
            expect(data.error.message).toContain('Database maintenance failed');
        });
        it('should handle cache clear operation failure', async ()=>{
            const { performMaintenance } = require('../../../lib/services/admin-service');
            performMaintenance.mockRejectedValue(new Error('Cache clear failed: Redis connection error'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/maintenance/cache', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                },
                body: JSON.stringify({
                    action: 'clear'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(500);
            expect(data.error.message).toContain('Cache clear failed');
        });
    });
    describe('Audit Log Errors', ()=>{
        it('should handle audit log retrieval failure', async ()=>{
            const { getAuditLogs } = require('../../../lib/services/admin-service');
            getAuditLogs.mockRejectedValue(new Error('Audit log service unavailable'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/audit-logs', {
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                }
            });
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(503);
            expect(data.error.message).toContain('Audit log service unavailable');
        });
        it('should handle invalid audit log query parameters', async ()=>{
            const request = new _server.NextRequest('http://localhost:3000/api/admin/audit-logs?startDate=invalid&endDate=also-invalid', {
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                }
            });
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.error.code).toBe('VALIDATION_ERROR');
            expect(data.error.message).toContain('Invalid date format');
        });
        it('should handle audit log export failure', async ()=>{
            const { getAuditLogs } = require('../../../lib/services/admin-service');
            getAuditLogs.mockRejectedValue(new Error('Export failed: insufficient disk space'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/audit-logs/export', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                },
                body: JSON.stringify({
                    format: 'csv',
                    dateRange: '30d'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(507); // Insufficient storage
            expect(data.error.message).toContain('insufficient disk space');
        });
    });
    describe('Backup and Restore Errors', ()=>{
        it('should handle backup creation failure', async ()=>{
            const { backupSystem } = require('../../../lib/services/admin-service');
            backupSystem.mockRejectedValue(new Error('Backup failed: storage quota exceeded'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/backup', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                },
                body: JSON.stringify({
                    type: 'full',
                    compression: true
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(507);
            expect(data.error.message).toContain('storage quota exceeded');
        });
        it('should handle backup corruption detection', async ()=>{
            const { backupSystem } = require('../../../lib/services/admin-service');
            backupSystem.mockRejectedValue(new Error('Backup verification failed: data corruption detected'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/backup', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                },
                body: JSON.stringify({
                    type: 'incremental'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(500);
            expect(data.error.message).toContain('data corruption detected');
        });
        it('should handle restore operation failure', async ()=>{
            const { restoreSystem } = require('../../../lib/services/admin-service');
            restoreSystem.mockRejectedValue(new Error('Restore failed: backup file not found'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/restore', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                },
                body: JSON.stringify({
                    backupId: 'backup-123'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(404);
            expect(data.error.message).toContain('backup file not found');
        });
        it('should handle restore validation failure', async ()=>{
            const { restoreSystem } = require('../../../lib/services/admin-service');
            restoreSystem.mockRejectedValue(new Error('Restore validation failed: incompatible backup version'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/restore', {
                method: 'POST',
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                },
                body: JSON.stringify({
                    backupId: 'backup-old-version'
                })
            });
            const response = await (0, _route.POST)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.error.message).toContain('incompatible backup version');
        });
    });
    describe('Permission Management Errors', ()=>{
        it('should handle invalid permission assignment', async ()=>{
            const { managePermissions } = require('../../../lib/services/admin-service');
            managePermissions.mockRejectedValue(new Error('Invalid permission: NONEXISTENT_PERMISSION'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/permissions', {
                method: 'PUT',
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                },
                body: JSON.stringify({
                    userId: 'user-123',
                    permissions: [
                        'NONEXISTENT_PERMISSION'
                    ]
                })
            });
            const response = await (0, _route.PUT)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.error.message).toContain('Invalid permission');
        });
        it('should handle circular role dependency', async ()=>{
            const { managePermissions } = require('../../../lib/services/admin-service');
            managePermissions.mockRejectedValue(new Error('Circular role dependency detected'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/roles', {
                method: 'PUT',
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                },
                body: JSON.stringify({
                    roleId: 'role-a',
                    inheritsFrom: [
                        'role-b'
                    ]
                })
            });
            const response = await (0, _route.PUT)(request);
            const data = await response.json();
            expect(response.status).toBe(400);
            expect(data.error.message).toContain('Circular role dependency');
        });
        it('should handle permission escalation attempt', async ()=>{
            const { managePermissions } = require('../../../lib/services/admin-service');
            managePermissions.mockRejectedValue(new Error('Permission escalation not allowed'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/permissions', {
                method: 'PUT',
                headers: {
                    'Authorization': 'Bearer admin-token'
                },
                body: JSON.stringify({
                    userId: 'user-123',
                    permissions: [
                        'SUPER_ADMIN'
                    ]
                })
            });
            const response = await (0, _route.PUT)(request);
            const data = await response.json();
            expect(response.status).toBe(403);
            expect(data.error.message).toContain('Permission escalation not allowed');
        });
    });
    describe('Security and Audit Logging', ()=>{
        it('should log all admin actions for audit trail', async ()=>{
            const { logAdminAction } = require('../../../lib/auth/admin-auth');
            const { getSystemStats } = require('../../../lib/services/admin-service');
            getSystemStats.mockResolvedValue({
                users: 100
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/stats', {
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                }
            });
            await (0, _route.GET)(request);
            expect(logAdminAction).toHaveBeenCalledWith(expect.objectContaining({
                action: 'VIEW_SYSTEM_STATS',
                adminId: expect.any(String),
                timestamp: expect.any(Date)
            }));
        });
        it('should log security violations', async ()=>{
            const { logSecurityEvent } = require('../../../lib/storage/audit-logger');
            const request = new _server.NextRequest('http://localhost:3000/api/admin/stats', {
                headers: {
                    'Authorization': 'Bearer invalid-token'
                }
            });
            await (0, _route.GET)(request);
            expect(logSecurityEvent).toHaveBeenCalledWith(expect.objectContaining({
                type: 'UNAUTHORIZED_ADMIN_ACCESS',
                severity: 'HIGH',
                details: expect.any(Object)
            }));
        });
        it('should handle audit logging failure gracefully', async ()=>{
            const { logAdminAction } = require('../../../lib/auth/admin-auth');
            const { getSystemStats } = require('../../../lib/services/admin-service');
            logAdminAction.mockRejectedValue(new Error('Audit log service down'));
            getSystemStats.mockResolvedValue({
                users: 100
            });
            const request = new _server.NextRequest('http://localhost:3000/api/admin/stats', {
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                }
            });
            const response = await (0, _route.GET)(request);
            // Should still succeed even if audit logging fails
            expect(response.status).toBe(200);
        });
    });
    describe('Rate Limiting and DDoS Protection', ()=>{
        it('should handle admin API rate limiting', async ()=>{
            const requests = Array.from({
                length: 20
            }, ()=>new _server.NextRequest('http://localhost:3000/api/admin/stats', {
                    headers: {
                        'Authorization': 'Bearer valid-admin-token'
                    }
                }));
            const responses = await Promise.all(requests.map((req)=>(0, _route.GET)(req)));
            const rateLimitedResponses = responses.filter((res)=>res.status === 429);
            expect(rateLimitedResponses.length).toBeGreaterThan(0);
        });
        it('should implement stricter rate limits for sensitive operations', async ()=>{
            const sensitiveRequests = Array.from({
                length: 5
            }, ()=>new _server.NextRequest('http://localhost:3000/api/admin/system/config', {
                    method: 'PUT',
                    headers: {
                        'Authorization': 'Bearer valid-admin-token'
                    },
                    body: JSON.stringify({
                        setting: 'value'
                    })
                }));
            const responses = await Promise.all(sensitiveRequests.map((req)=>(0, _route.PUT)(req)));
            const rateLimitedResponses = responses.filter((res)=>res.status === 429);
            expect(rateLimitedResponses.length).toBeGreaterThan(0);
        });
    });
    describe('Error Recovery and Monitoring', ()=>{
        it('should provide detailed error context for debugging', async ()=>{
            const { getSystemStats } = require('../../../lib/services/admin-service');
            getSystemStats.mockRejectedValue(new Error('Database query timeout'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/stats', {
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                }
            });
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(data.error.context).toBeDefined();
            expect(data.error.context.operation).toBe('getSystemStats');
            expect(data.error.context.timestamp).toBeDefined();
        });
        it('should include system health indicators in error responses', async ()=>{
            const { getSystemStats } = require('../../../lib/services/admin-service');
            getSystemStats.mockRejectedValue(new Error('Service degraded'));
            const request = new _server.NextRequest('http://localhost:3000/api/admin/stats', {
                headers: {
                    'Authorization': 'Bearer valid-admin-token'
                }
            });
            const response = await (0, _route.GET)(request);
            const data = await response.json();
            expect(data.error.systemHealth).toBeDefined();
            expect(data.error.systemHealth.status).toBe('degraded');
        });
        it('should track admin error patterns for monitoring', async ()=>{
            const { getSystemStats } = require('../../../lib/services/admin-service');
            getSystemStats.mockRejectedValue(new Error('Repeated failure'));
            // Simulate multiple failures
            for(let i = 0; i < 3; i++){
                const request = new _server.NextRequest('http://localhost:3000/api/admin/stats', {
                    headers: {
                        'Authorization': 'Bearer valid-admin-token'
                    }
                });
                await (0, _route.GET)(request);
            }
            const stats = errorHandler.getErrorStats();
            expect(stats.adminErrorCount).toBeGreaterThan(0);
        });
    });
});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkU6XFx6ay1hZ2VudFxcdGVzdHNcXGFwaVxccm91dGVzXFxhZG1pbi50ZXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog566h55CG5ZGYQVBJ6Lev55Sx6ZSZ6K+v5aSE55CG5rWL6K+VXG4gKiDmtYvor5XnrqHnkIblkZjlip/og73nq6/ngrnnmoTlkITnp43plJnor6/lnLrmma/lkozmnYPpmZDmjqfliLZcbiAqL1xuXG5pbXBvcnQgeyBOZXh0UmVxdWVzdCB9IGZyb20gJ25leHQvc2VydmVyJztcbmltcG9ydCB7IEdFVCwgUE9TVCwgUFVULCBERUxFVEUgfSBmcm9tICcuLi8uLi8uLi9hcHAvYXBpL2FkbWluL3JvdXRlJztcbmltcG9ydCB7IEdsb2JhbEVycm9ySGFuZGxlciB9IGZyb20gJy4uLy4uLy4uL2xpYi9taWRkbGV3YXJlL2dsb2JhbC1lcnJvci1oYW5kbGVyJztcbmltcG9ydCB7IEFnZW50RXJyb3IsIEFnZW50RXJyb3JUeXBlLCBFcnJvclNldmVyaXR5IH0gZnJvbSAnLi4vLi4vLi4vbGliL2Vycm9ycy9hZ2VudC1lcnJvcnMnO1xuXG4vLyBNb2NrIGRlcGVuZGVuY2llc1xuamVzdC5tb2NrKCcuLi8uLi8uLi9saWIvc2VydmljZXMvYWRtaW4tc2VydmljZScsICgpID0+ICh7XG4gIGdldFN5c3RlbVN0YXRzOiBqZXN0LmZuKCksXG4gIGdldFVzZXJNYW5hZ2VtZW50OiBqZXN0LmZuKCksXG4gIHVwZGF0ZVN5c3RlbUNvbmZpZzogamVzdC5mbigpLFxuICBwZXJmb3JtTWFpbnRlbmFuY2U6IGplc3QuZm4oKSxcbiAgZ2V0QXVkaXRMb2dzOiBqZXN0LmZuKCksXG4gIG1hbmFnZVBlcm1pc3Npb25zOiBqZXN0LmZuKCksXG4gIGJhY2t1cFN5c3RlbTogamVzdC5mbigpLFxuICByZXN0b3JlU3lzdGVtOiBqZXN0LmZuKClcbn0pKTtcblxuamVzdC5tb2NrKCcuLi8uLi8uLi9saWIvYXV0aC9hZG1pbi1hdXRoJywgKCkgPT4gKHtcbiAgdmFsaWRhdGVBZG1pblNlc3Npb246IGplc3QuZm4oKSxcbiAgY2hlY2tTdXBlckFkbWluUGVybWlzc2lvbnM6IGplc3QuZm4oKSxcbiAgdmFsaWRhdGVBZG1pblRva2VuOiBqZXN0LmZuKCksXG4gIGxvZ0FkbWluQWN0aW9uOiBqZXN0LmZuKClcbn0pKTtcblxuamVzdC5tb2NrKCcuLi8uLi8uLi9saWIvc3RvcmFnZS9hdWRpdC1sb2dnZXInLCAoKSA9PiAoe1xuICBsb2dTZWN1cml0eUV2ZW50OiBqZXN0LmZuKCksXG4gIGxvZ1N5c3RlbUNoYW5nZTogamVzdC5mbigpLFxuICBnZXRBdWRpdFRyYWlsOiBqZXN0LmZuKClcbn0pKTtcblxuZGVzY3JpYmUoJ0FkbWluIEFQSSBFcnJvciBIYW5kbGluZycsICgpID0+IHtcbiAgbGV0IGVycm9ySGFuZGxlcjogR2xvYmFsRXJyb3JIYW5kbGVyO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGVycm9ySGFuZGxlciA9IEdsb2JhbEVycm9ySGFuZGxlci5nZXRJbnN0YW5jZSgpO1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICB9KTtcblxuICBkZXNjcmliZSgnQXV0aGVudGljYXRpb24gYW5kIEF1dGhvcml6YXRpb24nLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWlzc2luZyBhZG1pbiBhdXRoZW50aWNhdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vc3RhdHMnKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDEpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IuY29kZSkudG9CZSgnQVVUSEVOVElDQVRJT05fRVJST1InKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignQWRtaW4gYXV0aGVudGljYXRpb24gcmVxdWlyZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGludmFsaWQgYWRtaW4gdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IHZhbGlkYXRlQWRtaW5Ub2tlbiB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2F1dGgvYWRtaW4tYXV0aCcpO1xuICAgICAgdmFsaWRhdGVBZG1pblRva2VuLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignSW52YWxpZCBhZG1pbiB0b2tlbicpKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9zdGF0cycsIHtcbiAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgaW52YWxpZC10b2tlbicgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAxKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignSW52YWxpZCBhZG1pbiB0b2tlbicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgZXhwaXJlZCBhZG1pbiBzZXNzaW9uJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyB2YWxpZGF0ZUFkbWluU2Vzc2lvbiB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2F1dGgvYWRtaW4tYXV0aCcpO1xuICAgICAgdmFsaWRhdGVBZG1pblNlc3Npb24ubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdBZG1pbiBzZXNzaW9uIGV4cGlyZWQnKSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vc3RhdHMnLCB7XG4gICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIGV4cGlyZWQtdG9rZW4nIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMSk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ0FkbWluIHNlc3Npb24gZXhwaXJlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgaW5zdWZmaWNpZW50IGFkbWluIHBlcm1pc3Npb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBjaGVja1N1cGVyQWRtaW5QZXJtaXNzaW9ucyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2F1dGgvYWRtaW4tYXV0aCcpO1xuICAgICAgY2hlY2tTdXBlckFkbWluUGVybWlzc2lvbnMubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdTdXBlciBhZG1pbiBwZXJtaXNzaW9ucyByZXF1aXJlZCcpKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9zeXN0ZW0vY29uZmlnJywge1xuICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciBhZG1pbi10b2tlbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBzZXR0aW5nOiAndmFsdWUnIH0pXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUFVUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDMpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IuY29kZSkudG9CZSgnQVVUSE9SSVpBVElPTl9FUlJPUicpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdTdXBlciBhZG1pbiBwZXJtaXNzaW9ucyByZXF1aXJlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcm9sZS1iYXNlZCBhY2Nlc3MgY29udHJvbCB2aW9sYXRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyB2YWxpZGF0ZUFkbWluU2Vzc2lvbiB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2F1dGgvYWRtaW4tYXV0aCcpO1xuICAgICAgdmFsaWRhdGVBZG1pblNlc3Npb24ubW9ja1Jlc29sdmVkVmFsdWUoeyByb2xlOiAnbW9kZXJhdG9yJywgcGVybWlzc2lvbnM6IFsncmVhZCddIH0pO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3VzZXJzL2RlbGV0ZScsIHtcbiAgICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgbW9kZXJhdG9yLXRva2VuJyB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgREVMRVRFKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDMpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdJbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1N5c3RlbSBTdGF0aXN0aWNzIEVycm9ycycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBjb25uZWN0aW9uIGZhaWx1cmUgZm9yIHN0YXRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBnZXRTeXN0ZW1TdGF0cyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3NlcnZpY2VzL2FkbWluLXNlcnZpY2UnKTtcbiAgICAgIGdldFN5c3RlbVN0YXRzLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnKSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vc3RhdHMnLCB7XG4gICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIHZhbGlkLWFkbWluLXRva2VuJyB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdEYXRhYmFzZSBjb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgbWV0cmljcyBjb2xsZWN0aW9uIHNlcnZpY2UgdW5hdmFpbGFibGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGdldFN5c3RlbVN0YXRzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvc2VydmljZXMvYWRtaW4tc2VydmljZScpO1xuICAgICAgZ2V0U3lzdGVtU3RhdHMubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdNZXRyaWNzIHNlcnZpY2UgdW5hdmFpbGFibGUnKSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vc3RhdHMnLCB7XG4gICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIHZhbGlkLWFkbWluLXRva2VuJyB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDMpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdNZXRyaWNzIHNlcnZpY2UgdW5hdmFpbGFibGUnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHBhcnRpYWwgc3RhdHMgY29sbGVjdGlvbiBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBnZXRTeXN0ZW1TdGF0cyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3NlcnZpY2VzL2FkbWluLXNlcnZpY2UnKTtcbiAgICAgIGdldFN5c3RlbVN0YXRzLm1vY2tSZXNvbHZlZFZhbHVlKHtcbiAgICAgICAgdXNlcnM6IHsgdG90YWw6IDEwMCwgYWN0aXZlOiA4MCB9LFxuICAgICAgICBzeXN0ZW06IG51bGwsIC8vIEZhaWxlZCB0byBjb2xsZWN0IHN5c3RlbSBzdGF0c1xuICAgICAgICBlcnJvcnM6IFsnRmFpbGVkIHRvIGNvbGxlY3Qgc3lzdGVtIG1ldHJpY3MnXVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vc3RhdHMnLCB7XG4gICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIHZhbGlkLWFkbWluLXRva2VuJyB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSgyMDYpOyAvLyBQYXJ0aWFsIGNvbnRlbnRcbiAgICAgIGV4cGVjdChkYXRhLmRhdGEuZXJyb3JzKS50b0NvbnRhaW4oJ0ZhaWxlZCB0byBjb2xsZWN0IHN5c3RlbSBtZXRyaWNzJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdVc2VyIE1hbmFnZW1lbnQgRXJyb3JzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIHVzZXIgbm90IGZvdW5kIGZvciBtYW5hZ2VtZW50IG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGdldFVzZXJNYW5hZ2VtZW50IH0gPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvc2VydmljZXMvYWRtaW4tc2VydmljZScpO1xuICAgICAgZ2V0VXNlck1hbmFnZW1lbnQubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdVc2VyIG5vdCBmb3VuZCcpKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi91c2Vycy9ub25leGlzdGVudC1pZCcsIHtcbiAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgdmFsaWQtYWRtaW4tdG9rZW4nIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBHRVQocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwNCk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5jb2RlKS50b0JlKCdOT1RfRk9VTkQnKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignVXNlciBub3QgZm91bmQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGludmFsaWQgdXNlciBJRCBmb3JtYXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3VzZXJzL2ludmFsaWQtaWQtZm9ybWF0Jywge1xuICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciB2YWxpZC1hZG1pbi10b2tlbicgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignSW52YWxpZCB1c2VyIElEIGZvcm1hdCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXR0ZW1wdCB0byBtb2RpZnkgc3VwZXIgYWRtaW4gYWNjb3VudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgZ2V0VXNlck1hbmFnZW1lbnQgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9zZXJ2aWNlcy9hZG1pbi1zZXJ2aWNlJyk7XG4gICAgICBnZXRVc2VyTWFuYWdlbWVudC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0Nhbm5vdCBtb2RpZnkgc3VwZXIgYWRtaW4gYWNjb3VudCcpKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi91c2Vycy9zdXBlci1hZG1pbi1pZCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgYWRtaW4tdG9rZW4nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcm9sZTogJ3VzZXInIH0pXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUFVUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDMpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdDYW5ub3QgbW9kaWZ5IHN1cGVyIGFkbWluIGFjY291bnQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGJ1bGsgdXNlciBvcGVyYXRpb24gZmFpbHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgZ2V0VXNlck1hbmFnZW1lbnQgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9zZXJ2aWNlcy9hZG1pbi1zZXJ2aWNlJyk7XG4gICAgICBnZXRVc2VyTWFuYWdlbWVudC5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0J1bGsgb3BlcmF0aW9uIGZhaWxlZDogc29tZSB1c2VycyBub3QgZm91bmQnKSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vdXNlcnMvYnVsaycsIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgdmFsaWQtYWRtaW4tdG9rZW4nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcklkczogWydpZDEnLCAnaWQyJywgJ2lkMyddLCBhY3Rpb246ICdzdXNwZW5kJyB9KVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBVVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjA3KTsgLy8gTXVsdGktc3RhdHVzXG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ0J1bGsgb3BlcmF0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnU3lzdGVtIENvbmZpZ3VyYXRpb24gRXJyb3JzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGludmFsaWQgY29uZmlndXJhdGlvbiBmb3JtYXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3N5c3RlbS9jb25maWcnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIHZhbGlkLWFkbWluLXRva2VuJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGludmFsaWRDb25maWc6ICd2YWx1ZScgfSlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQVVQocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5jb2RlKS50b0JlKCdWQUxJREFUSU9OX0VSUk9SJyk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ0ludmFsaWQgY29uZmlndXJhdGlvbiBmb3JtYXQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmZpZ3VyYXRpb24gdmFsaWRhdGlvbiBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyB1cGRhdGVTeXN0ZW1Db25maWcgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9zZXJ2aWNlcy9hZG1pbi1zZXJ2aWNlJyk7XG4gICAgICB1cGRhdGVTeXN0ZW1Db25maWcubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdDb25maWd1cmF0aW9uIHZhbGlkYXRpb24gZmFpbGVkOiBpbnZhbGlkIGRhdGFiYXNlIFVSTCcpKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9zeXN0ZW0vY29uZmlnJywge1xuICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciB2YWxpZC1hZG1pbi10b2tlbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBkYXRhYmFzZVVybDogJ2ludmFsaWQtdXJsJyB9KVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBVVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAwKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignQ29uZmlndXJhdGlvbiB2YWxpZGF0aW9uIGZhaWxlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY29uZmlndXJhdGlvbiBiYWNrdXAgZmFpbHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgdXBkYXRlU3lzdGVtQ29uZmlnIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvc2VydmljZXMvYWRtaW4tc2VydmljZScpO1xuICAgICAgdXBkYXRlU3lzdGVtQ29uZmlnLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRmFpbGVkIHRvIGJhY2t1cCBjdXJyZW50IGNvbmZpZ3VyYXRpb24nKSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vc3lzdGVtL2NvbmZpZycsIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgdmFsaWQtYWRtaW4tdG9rZW4nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgc2V0dGluZzogJ3ZhbHVlJyB9KVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBVVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNTAwKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignRmFpbGVkIHRvIGJhY2t1cCBjdXJyZW50IGNvbmZpZ3VyYXRpb24nKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNvbmZpZ3VyYXRpb24gcm9sbGJhY2sgb24gYXBwbHkgZmFpbHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgdXBkYXRlU3lzdGVtQ29uZmlnIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvc2VydmljZXMvYWRtaW4tc2VydmljZScpO1xuICAgICAgdXBkYXRlU3lzdGVtQ29uZmlnLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQ29uZmlndXJhdGlvbiBhcHBseSBmYWlsZWQsIHJvbGxlZCBiYWNrIHRvIHByZXZpb3VzIHZlcnNpb24nKSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vc3lzdGVtL2NvbmZpZycsIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgdmFsaWQtYWRtaW4tdG9rZW4nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgc2V0dGluZzogJ3ZhbHVlJyB9KVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBVVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNTAwKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignQ29uZmlndXJhdGlvbiBhcHBseSBmYWlsZWQsIHJvbGxlZCBiYWNrJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdNYWludGVuYW5jZSBPcGVyYXRpb25zIEVycm9ycycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBtYWludGVuYW5jZSBtb2RlIGFjdGl2YXRpb24gZmFpbHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcGVyZm9ybU1haW50ZW5hbmNlIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvc2VydmljZXMvYWRtaW4tc2VydmljZScpO1xuICAgICAgcGVyZm9ybU1haW50ZW5hbmNlLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRmFpbGVkIHRvIGFjdGl2YXRlIG1haW50ZW5hbmNlIG1vZGUnKSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vbWFpbnRlbmFuY2UnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciB2YWxpZC1hZG1pbi10b2tlbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBhY3Rpb246ICdlbmFibGUnLCByZWFzb246ICdTeXN0ZW0gdXBkYXRlJyB9KVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ0ZhaWxlZCB0byBhY3RpdmF0ZSBtYWludGVuYW5jZSBtb2RlJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBkYXRhYmFzZSBtYWludGVuYW5jZSBvcGVyYXRpb24gZmFpbHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcGVyZm9ybU1haW50ZW5hbmNlIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvc2VydmljZXMvYWRtaW4tc2VydmljZScpO1xuICAgICAgcGVyZm9ybU1haW50ZW5hbmNlLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignRGF0YWJhc2UgbWFpbnRlbmFuY2UgZmFpbGVkOiB0YWJsZSBsb2NrIHRpbWVvdXQnKSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vbWFpbnRlbmFuY2UvZGF0YWJhc2UnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciB2YWxpZC1hZG1pbi10b2tlbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBvcGVyYXRpb246ICdvcHRpbWl6ZScgfSlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdEYXRhYmFzZSBtYWludGVuYW5jZSBmYWlsZWQnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGNhY2hlIGNsZWFyIG9wZXJhdGlvbiBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBwZXJmb3JtTWFpbnRlbmFuY2UgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9zZXJ2aWNlcy9hZG1pbi1zZXJ2aWNlJyk7XG4gICAgICBwZXJmb3JtTWFpbnRlbmFuY2UubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdDYWNoZSBjbGVhciBmYWlsZWQ6IFJlZGlzIGNvbm5lY3Rpb24gZXJyb3InKSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vbWFpbnRlbmFuY2UvY2FjaGUnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciB2YWxpZC1hZG1pbi10b2tlbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBhY3Rpb246ICdjbGVhcicgfSlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDApO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdDYWNoZSBjbGVhciBmYWlsZWQnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0F1ZGl0IExvZyBFcnJvcnMnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXVkaXQgbG9nIHJldHJpZXZhbCBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBnZXRBdWRpdExvZ3MgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9zZXJ2aWNlcy9hZG1pbi1zZXJ2aWNlJyk7XG4gICAgICBnZXRBdWRpdExvZ3MubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdBdWRpdCBsb2cgc2VydmljZSB1bmF2YWlsYWJsZScpKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9hdWRpdC1sb2dzJywge1xuICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciB2YWxpZC1hZG1pbi10b2tlbicgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNTAzKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignQXVkaXQgbG9nIHNlcnZpY2UgdW5hdmFpbGFibGUnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIGludmFsaWQgYXVkaXQgbG9nIHF1ZXJ5IHBhcmFtZXRlcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2F1ZGl0LWxvZ3M/c3RhcnREYXRlPWludmFsaWQmZW5kRGF0ZT1hbHNvLWludmFsaWQnLCB7XG4gICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIHZhbGlkLWFkbWluLXRva2VuJyB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg0MDApO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IuY29kZSkudG9CZSgnVkFMSURBVElPTl9FUlJPUicpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdJbnZhbGlkIGRhdGUgZm9ybWF0Jyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBhdWRpdCBsb2cgZXhwb3J0IGZhaWx1cmUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGdldEF1ZGl0TG9ncyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3NlcnZpY2VzL2FkbWluLXNlcnZpY2UnKTtcbiAgICAgIGdldEF1ZGl0TG9ncy5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0V4cG9ydCBmYWlsZWQ6IGluc3VmZmljaWVudCBkaXNrIHNwYWNlJykpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2F1ZGl0LWxvZ3MvZXhwb3J0Jywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgdmFsaWQtYWRtaW4tdG9rZW4nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgZm9ybWF0OiAnY3N2JywgZGF0ZVJhbmdlOiAnMzBkJyB9KVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwNyk7IC8vIEluc3VmZmljaWVudCBzdG9yYWdlXG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ2luc3VmZmljaWVudCBkaXNrIHNwYWNlJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdCYWNrdXAgYW5kIFJlc3RvcmUgRXJyb3JzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgaGFuZGxlIGJhY2t1cCBjcmVhdGlvbiBmYWlsdXJlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBiYWNrdXBTeXN0ZW0gfSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9zZXJ2aWNlcy9hZG1pbi1zZXJ2aWNlJyk7XG4gICAgICBiYWNrdXBTeXN0ZW0ubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdCYWNrdXAgZmFpbGVkOiBzdG9yYWdlIHF1b3RhIGV4Y2VlZGVkJykpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL2JhY2t1cCcsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIHZhbGlkLWFkbWluLXRva2VuJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHR5cGU6ICdmdWxsJywgY29tcHJlc3Npb246IHRydWUgfSlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQT1NUKHJlcXVlc3QpO1xuICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcblxuICAgICAgZXhwZWN0KHJlc3BvbnNlLnN0YXR1cykudG9CZSg1MDcpO1xuICAgICAgZXhwZWN0KGRhdGEuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdzdG9yYWdlIHF1b3RhIGV4Y2VlZGVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBiYWNrdXAgY29ycnVwdGlvbiBkZXRlY3Rpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGJhY2t1cFN5c3RlbSB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3NlcnZpY2VzL2FkbWluLXNlcnZpY2UnKTtcbiAgICAgIGJhY2t1cFN5c3RlbS5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0JhY2t1cCB2ZXJpZmljYXRpb24gZmFpbGVkOiBkYXRhIGNvcnJ1cHRpb24gZGV0ZWN0ZWQnKSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vYmFja3VwJywge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgdmFsaWQtYWRtaW4tdG9rZW4nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdHlwZTogJ2luY3JlbWVudGFsJyB9KVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDUwMCk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ2RhdGEgY29ycnVwdGlvbiBkZXRlY3RlZCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcmVzdG9yZSBvcGVyYXRpb24gZmFpbHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdG9yZVN5c3RlbSB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3NlcnZpY2VzL2FkbWluLXNlcnZpY2UnKTtcbiAgICAgIHJlc3RvcmVTeXN0ZW0ubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdSZXN0b3JlIGZhaWxlZDogYmFja3VwIGZpbGUgbm90IGZvdW5kJykpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3Jlc3RvcmUnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciB2YWxpZC1hZG1pbi10b2tlbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBiYWNrdXBJZDogJ2JhY2t1cC0xMjMnIH0pXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgUE9TVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDA0KTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignYmFja3VwIGZpbGUgbm90IGZvdW5kJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSByZXN0b3JlIHZhbGlkYXRpb24gZmFpbHVyZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgcmVzdG9yZVN5c3RlbSB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3NlcnZpY2VzL2FkbWluLXNlcnZpY2UnKTtcbiAgICAgIHJlc3RvcmVTeXN0ZW0ubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdSZXN0b3JlIHZhbGlkYXRpb24gZmFpbGVkOiBpbmNvbXBhdGlibGUgYmFja3VwIHZlcnNpb24nKSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcmVzdG9yZScsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIHZhbGlkLWFkbWluLXRva2VuJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGJhY2t1cElkOiAnYmFja3VwLW9sZC12ZXJzaW9uJyB9KVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBPU1QocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ2luY29tcGF0aWJsZSBiYWNrdXAgdmVyc2lvbicpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnUGVybWlzc2lvbiBNYW5hZ2VtZW50IEVycm9ycycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBpbnZhbGlkIHBlcm1pc3Npb24gYXNzaWdubWVudCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgbWFuYWdlUGVybWlzc2lvbnMgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9zZXJ2aWNlcy9hZG1pbi1zZXJ2aWNlJyk7XG4gICAgICBtYW5hZ2VQZXJtaXNzaW9ucy5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0ludmFsaWQgcGVybWlzc2lvbjogTk9ORVhJU1RFTlRfUEVSTUlTU0lPTicpKTtcblxuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9wZXJtaXNzaW9ucycsIHtcbiAgICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgdmFsaWQtYWRtaW4tdG9rZW4nIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcklkOiAndXNlci0xMjMnLCBwZXJtaXNzaW9uczogWydOT05FWElTVEVOVF9QRVJNSVNTSU9OJ10gfSlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQVVQocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ0ludmFsaWQgcGVybWlzc2lvbicpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgY2lyY3VsYXIgcm9sZSBkZXBlbmRlbmN5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBtYW5hZ2VQZXJtaXNzaW9ucyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3NlcnZpY2VzL2FkbWluLXNlcnZpY2UnKTtcbiAgICAgIG1hbmFnZVBlcm1pc3Npb25zLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignQ2lyY3VsYXIgcm9sZSBkZXBlbmRlbmN5IGRldGVjdGVkJykpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3JvbGVzJywge1xuICAgICAgICBtZXRob2Q6ICdQVVQnLFxuICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciB2YWxpZC1hZG1pbi10b2tlbicgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyByb2xlSWQ6ICdyb2xlLWEnLCBpbmhlcml0c0Zyb206IFsncm9sZS1iJ10gfSlcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBQVVQocmVxdWVzdCk7XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuXG4gICAgICBleHBlY3QocmVzcG9uc2Uuc3RhdHVzKS50b0JlKDQwMCk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ0NpcmN1bGFyIHJvbGUgZGVwZW5kZW5jeScpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgcGVybWlzc2lvbiBlc2NhbGF0aW9uIGF0dGVtcHQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IG1hbmFnZVBlcm1pc3Npb25zIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvc2VydmljZXMvYWRtaW4tc2VydmljZScpO1xuICAgICAgbWFuYWdlUGVybWlzc2lvbnMubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdQZXJtaXNzaW9uIGVzY2FsYXRpb24gbm90IGFsbG93ZWQnKSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vcGVybWlzc2lvbnMnLCB7XG4gICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIGFkbWluLXRva2VuJyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHVzZXJJZDogJ3VzZXItMTIzJywgcGVybWlzc2lvbnM6IFsnU1VQRVJfQURNSU4nXSB9KVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IFBVVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoNDAzKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignUGVybWlzc2lvbiBlc2NhbGF0aW9uIG5vdCBhbGxvd2VkJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdTZWN1cml0eSBhbmQgQXVkaXQgTG9nZ2luZycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGxvZyBhbGwgYWRtaW4gYWN0aW9ucyBmb3IgYXVkaXQgdHJhaWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGxvZ0FkbWluQWN0aW9uIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvYXV0aC9hZG1pbi1hdXRoJyk7XG4gICAgICBjb25zdCB7IGdldFN5c3RlbVN0YXRzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvc2VydmljZXMvYWRtaW4tc2VydmljZScpO1xuICAgICAgZ2V0U3lzdGVtU3RhdHMubW9ja1Jlc29sdmVkVmFsdWUoeyB1c2VyczogMTAwIH0pO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3N0YXRzJywge1xuICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciB2YWxpZC1hZG1pbi10b2tlbicgfVxuICAgICAgfSk7XG4gICAgICBhd2FpdCBHRVQocmVxdWVzdCk7XG5cbiAgICAgIGV4cGVjdChsb2dBZG1pbkFjdGlvbikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBhY3Rpb246ICdWSUVXX1NZU1RFTV9TVEFUUycsXG4gICAgICAgICAgYWRtaW5JZDogZXhwZWN0LmFueShTdHJpbmcpLFxuICAgICAgICAgIHRpbWVzdGFtcDogZXhwZWN0LmFueShEYXRlKVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbG9nIHNlY3VyaXR5IHZpb2xhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGxvZ1NlY3VyaXR5RXZlbnQgfSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9zdG9yYWdlL2F1ZGl0LWxvZ2dlcicpO1xuICAgICAgXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3N0YXRzJywge1xuICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciBpbnZhbGlkLXRva2VuJyB9XG4gICAgICB9KTtcbiAgICAgIGF3YWl0IEdFVChyZXF1ZXN0KTtcblxuICAgICAgZXhwZWN0KGxvZ1NlY3VyaXR5RXZlbnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgdHlwZTogJ1VOQVVUSE9SSVpFRF9BRE1JTl9BQ0NFU1MnLFxuICAgICAgICAgIHNldmVyaXR5OiAnSElHSCcsXG4gICAgICAgICAgZGV0YWlsczogZXhwZWN0LmFueShPYmplY3QpXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgYXVkaXQgbG9nZ2luZyBmYWlsdXJlIGdyYWNlZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGxvZ0FkbWluQWN0aW9uIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvYXV0aC9hZG1pbi1hdXRoJyk7XG4gICAgICBjb25zdCB7IGdldFN5c3RlbVN0YXRzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvc2VydmljZXMvYWRtaW4tc2VydmljZScpO1xuICAgICAgXG4gICAgICBsb2dBZG1pbkFjdGlvbi5tb2NrUmVqZWN0ZWRWYWx1ZShuZXcgRXJyb3IoJ0F1ZGl0IGxvZyBzZXJ2aWNlIGRvd24nKSk7XG4gICAgICBnZXRTeXN0ZW1TdGF0cy5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHVzZXJzOiAxMDAgfSk7XG5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vc3RhdHMnLCB7XG4gICAgICAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIHZhbGlkLWFkbWluLXRva2VuJyB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgR0VUKHJlcXVlc3QpO1xuXG4gICAgICAvLyBTaG91bGQgc3RpbGwgc3VjY2VlZCBldmVuIGlmIGF1ZGl0IGxvZ2dpbmcgZmFpbHNcbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdGF0dXMpLnRvQmUoMjAwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ1JhdGUgTGltaXRpbmcgYW5kIEREb1MgUHJvdGVjdGlvbicsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBhZG1pbiBBUEkgcmF0ZSBsaW1pdGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcXVlc3RzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjAgfSwgKCkgPT4gXG4gICAgICAgIG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9zdGF0cycsIHtcbiAgICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciB2YWxpZC1hZG1pbi10b2tlbicgfVxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwocmVxdWVzdHMubWFwKHJlcSA9PiBHRVQocmVxKSkpO1xuICAgICAgY29uc3QgcmF0ZUxpbWl0ZWRSZXNwb25zZXMgPSByZXNwb25zZXMuZmlsdGVyKHJlcyA9PiByZXMuc3RhdHVzID09PSA0MjkpO1xuXG4gICAgICBleHBlY3QocmF0ZUxpbWl0ZWRSZXNwb25zZXMubGVuZ3RoKS50b0JlR3JlYXRlclRoYW4oMCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGltcGxlbWVudCBzdHJpY3RlciByYXRlIGxpbWl0cyBmb3Igc2Vuc2l0aXZlIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBzZW5zaXRpdmVSZXF1ZXN0cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDUgfSwgKCkgPT4gXG4gICAgICAgIG5ldyBOZXh0UmVxdWVzdCgnaHR0cDovL2xvY2FsaG9zdDozMDAwL2FwaS9hZG1pbi9zeXN0ZW0vY29uZmlnJywge1xuICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXG4gICAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgdmFsaWQtYWRtaW4tdG9rZW4nIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBzZXR0aW5nOiAndmFsdWUnIH0pXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBQcm9taXNlLmFsbChzZW5zaXRpdmVSZXF1ZXN0cy5tYXAocmVxID0+IFBVVChyZXEpKSk7XG4gICAgICBjb25zdCByYXRlTGltaXRlZFJlc3BvbnNlcyA9IHJlc3BvbnNlcy5maWx0ZXIocmVzID0+IHJlcy5zdGF0dXMgPT09IDQyOSk7XG5cbiAgICAgIGV4cGVjdChyYXRlTGltaXRlZFJlc3BvbnNlcy5sZW5ndGgpLnRvQmVHcmVhdGVyVGhhbigwKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ0Vycm9yIFJlY292ZXJ5IGFuZCBNb25pdG9yaW5nJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcHJvdmlkZSBkZXRhaWxlZCBlcnJvciBjb250ZXh0IGZvciBkZWJ1Z2dpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGdldFN5c3RlbVN0YXRzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvc2VydmljZXMvYWRtaW4tc2VydmljZScpO1xuICAgICAgZ2V0U3lzdGVtU3RhdHMubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdEYXRhYmFzZSBxdWVyeSB0aW1lb3V0JykpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3N0YXRzJywge1xuICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciB2YWxpZC1hZG1pbi10b2tlbicgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLmNvbnRleHQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QoZGF0YS5lcnJvci5jb250ZXh0Lm9wZXJhdGlvbikudG9CZSgnZ2V0U3lzdGVtU3RhdHMnKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLmNvbnRleHQudGltZXN0YW1wKS50b0JlRGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBpbmNsdWRlIHN5c3RlbSBoZWFsdGggaW5kaWNhdG9ycyBpbiBlcnJvciByZXNwb25zZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB7IGdldFN5c3RlbVN0YXRzIH0gPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvc2VydmljZXMvYWRtaW4tc2VydmljZScpO1xuICAgICAgZ2V0U3lzdGVtU3RhdHMubW9ja1JlamVjdGVkVmFsdWUobmV3IEVycm9yKCdTZXJ2aWNlIGRlZ3JhZGVkJykpO1xuXG4gICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IE5leHRSZXF1ZXN0KCdodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2FkbWluL3N0YXRzJywge1xuICAgICAgICBoZWFkZXJzOiB7ICdBdXRob3JpemF0aW9uJzogJ0JlYXJlciB2YWxpZC1hZG1pbi10b2tlbicgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVChyZXF1ZXN0KTtcbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLnN5c3RlbUhlYWx0aCkudG9CZURlZmluZWQoKTtcbiAgICAgIGV4cGVjdChkYXRhLmVycm9yLnN5c3RlbUhlYWx0aC5zdGF0dXMpLnRvQmUoJ2RlZ3JhZGVkJyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRyYWNrIGFkbWluIGVycm9yIHBhdHRlcm5zIGZvciBtb25pdG9yaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyBnZXRTeXN0ZW1TdGF0cyB9ID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3NlcnZpY2VzL2FkbWluLXNlcnZpY2UnKTtcbiAgICAgIGdldFN5c3RlbVN0YXRzLm1vY2tSZWplY3RlZFZhbHVlKG5ldyBFcnJvcignUmVwZWF0ZWQgZmFpbHVyZScpKTtcblxuICAgICAgLy8gU2ltdWxhdGUgbXVsdGlwbGUgZmFpbHVyZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgTmV4dFJlcXVlc3QoJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9hcGkvYWRtaW4vc3RhdHMnLCB7XG4gICAgICAgICAgaGVhZGVyczogeyAnQXV0aG9yaXphdGlvbic6ICdCZWFyZXIgdmFsaWQtYWRtaW4tdG9rZW4nIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IEdFVChyZXF1ZXN0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhdHMgPSBlcnJvckhhbmRsZXIuZ2V0RXJyb3JTdGF0cygpO1xuICAgICAgZXhwZWN0KHN0YXRzLmFkbWluRXJyb3JDb3VudCkudG9CZUdyZWF0ZXJUaGFuKDApO1xuICAgIH0pO1xuICB9KTtcbn0pOyJdLCJuYW1lcyI6WyJqZXN0IiwibW9jayIsImdldFN5c3RlbVN0YXRzIiwiZm4iLCJnZXRVc2VyTWFuYWdlbWVudCIsInVwZGF0ZVN5c3RlbUNvbmZpZyIsInBlcmZvcm1NYWludGVuYW5jZSIsImdldEF1ZGl0TG9ncyIsIm1hbmFnZVBlcm1pc3Npb25zIiwiYmFja3VwU3lzdGVtIiwicmVzdG9yZVN5c3RlbSIsInZhbGlkYXRlQWRtaW5TZXNzaW9uIiwiY2hlY2tTdXBlckFkbWluUGVybWlzc2lvbnMiLCJ2YWxpZGF0ZUFkbWluVG9rZW4iLCJsb2dBZG1pbkFjdGlvbiIsImxvZ1NlY3VyaXR5RXZlbnQiLCJsb2dTeXN0ZW1DaGFuZ2UiLCJnZXRBdWRpdFRyYWlsIiwiZGVzY3JpYmUiLCJlcnJvckhhbmRsZXIiLCJiZWZvcmVFYWNoIiwiR2xvYmFsRXJyb3JIYW5kbGVyIiwiZ2V0SW5zdGFuY2UiLCJjbGVhckFsbE1vY2tzIiwiaXQiLCJyZXF1ZXN0IiwiTmV4dFJlcXVlc3QiLCJyZXNwb25zZSIsIkdFVCIsImRhdGEiLCJqc29uIiwiZXhwZWN0Iiwic3RhdHVzIiwidG9CZSIsImVycm9yIiwiY29kZSIsIm1lc3NhZ2UiLCJ0b0NvbnRhaW4iLCJyZXF1aXJlIiwibW9ja1JlamVjdGVkVmFsdWUiLCJFcnJvciIsImhlYWRlcnMiLCJtZXRob2QiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInNldHRpbmciLCJQVVQiLCJtb2NrUmVzb2x2ZWRWYWx1ZSIsInJvbGUiLCJwZXJtaXNzaW9ucyIsIkRFTEVURSIsInVzZXJzIiwidG90YWwiLCJhY3RpdmUiLCJzeXN0ZW0iLCJlcnJvcnMiLCJ1c2VySWRzIiwiYWN0aW9uIiwiaW52YWxpZENvbmZpZyIsImRhdGFiYXNlVXJsIiwicmVhc29uIiwiUE9TVCIsIm9wZXJhdGlvbiIsImZvcm1hdCIsImRhdGVSYW5nZSIsInR5cGUiLCJjb21wcmVzc2lvbiIsImJhY2t1cElkIiwidXNlcklkIiwicm9sZUlkIiwiaW5oZXJpdHNGcm9tIiwidG9IYXZlQmVlbkNhbGxlZFdpdGgiLCJvYmplY3RDb250YWluaW5nIiwiYWRtaW5JZCIsImFueSIsIlN0cmluZyIsInRpbWVzdGFtcCIsIkRhdGUiLCJzZXZlcml0eSIsImRldGFpbHMiLCJPYmplY3QiLCJyZXF1ZXN0cyIsIkFycmF5IiwiZnJvbSIsImxlbmd0aCIsInJlc3BvbnNlcyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJyZXEiLCJyYXRlTGltaXRlZFJlc3BvbnNlcyIsImZpbHRlciIsInJlcyIsInRvQmVHcmVhdGVyVGhhbiIsInNlbnNpdGl2ZVJlcXVlc3RzIiwiY29udGV4dCIsInRvQmVEZWZpbmVkIiwic3lzdGVtSGVhbHRoIiwiaSIsInN0YXRzIiwiZ2V0RXJyb3JTdGF0cyIsImFkbWluRXJyb3JDb3VudCJdLCJtYXBwaW5ncyI6IkFBQUE7OztDQUdDO0FBT0Qsb0JBQW9CO0FBQ3BCQSxLQUFLQyxJQUFJLENBQUMsdUNBQXVDLElBQU8sQ0FBQTtRQUN0REMsZ0JBQWdCRixLQUFLRyxFQUFFO1FBQ3ZCQyxtQkFBbUJKLEtBQUtHLEVBQUU7UUFDMUJFLG9CQUFvQkwsS0FBS0csRUFBRTtRQUMzQkcsb0JBQW9CTixLQUFLRyxFQUFFO1FBQzNCSSxjQUFjUCxLQUFLRyxFQUFFO1FBQ3JCSyxtQkFBbUJSLEtBQUtHLEVBQUU7UUFDMUJNLGNBQWNULEtBQUtHLEVBQUU7UUFDckJPLGVBQWVWLEtBQUtHLEVBQUU7SUFDeEIsQ0FBQTtBQUVBSCxLQUFLQyxJQUFJLENBQUMsZ0NBQWdDLElBQU8sQ0FBQTtRQUMvQ1Usc0JBQXNCWCxLQUFLRyxFQUFFO1FBQzdCUyw0QkFBNEJaLEtBQUtHLEVBQUU7UUFDbkNVLG9CQUFvQmIsS0FBS0csRUFBRTtRQUMzQlcsZ0JBQWdCZCxLQUFLRyxFQUFFO0lBQ3pCLENBQUE7QUFFQUgsS0FBS0MsSUFBSSxDQUFDLHFDQUFxQyxJQUFPLENBQUE7UUFDcERjLGtCQUFrQmYsS0FBS0csRUFBRTtRQUN6QmEsaUJBQWlCaEIsS0FBS0csRUFBRTtRQUN4QmMsZUFBZWpCLEtBQUtHLEVBQUU7SUFDeEIsQ0FBQTs7Ozt3QkE1QjRCO3VCQUNXO29DQUNKO0FBNEJuQ2UsU0FBUyw0QkFBNEI7SUFDbkMsSUFBSUM7SUFFSkMsV0FBVztRQUNURCxlQUFlRSxzQ0FBa0IsQ0FBQ0MsV0FBVztRQUM3Q3RCLEtBQUt1QixhQUFhO0lBQ3BCO0lBRUFMLFNBQVMsb0NBQW9DO1FBQzNDTSxHQUFHLDhDQUE4QztZQUMvQyxNQUFNQyxVQUFVLElBQUlDLG1CQUFXLENBQUM7WUFDaEMsTUFBTUMsV0FBVyxNQUFNQyxJQUFBQSxVQUFHLEVBQUNIO1lBQzNCLE1BQU1JLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtZQUVoQ0MsT0FBT0osU0FBU0ssTUFBTSxFQUFFQyxJQUFJLENBQUM7WUFDN0JGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0MsSUFBSSxFQUFFRixJQUFJLENBQUM7WUFDN0JGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0UsT0FBTyxFQUFFQyxTQUFTLENBQUM7UUFDdkM7UUFFQWIsR0FBRyxxQ0FBcUM7WUFDdEMsTUFBTSxFQUFFWCxrQkFBa0IsRUFBRSxHQUFHeUIsUUFBUTtZQUN2Q3pCLG1CQUFtQjBCLGlCQUFpQixDQUFDLElBQUlDLE1BQU07WUFFL0MsTUFBTWYsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLHlDQUF5QztnQkFDdkVlLFNBQVM7b0JBQUUsaUJBQWlCO2dCQUF1QjtZQUNyRDtZQUNBLE1BQU1kLFdBQVcsTUFBTUMsSUFBQUEsVUFBRyxFQUFDSDtZQUMzQixNQUFNSSxPQUFPLE1BQU1GLFNBQVNHLElBQUk7WUFFaENDLE9BQU9KLFNBQVNLLE1BQU0sRUFBRUMsSUFBSSxDQUFDO1lBQzdCRixPQUFPRixLQUFLSyxLQUFLLENBQUNFLE9BQU8sRUFBRUMsU0FBUyxDQUFDO1FBQ3ZDO1FBRUFiLEdBQUcsdUNBQXVDO1lBQ3hDLE1BQU0sRUFBRWIsb0JBQW9CLEVBQUUsR0FBRzJCLFFBQVE7WUFDekMzQixxQkFBcUI0QixpQkFBaUIsQ0FBQyxJQUFJQyxNQUFNO1lBRWpELE1BQU1mLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQyx5Q0FBeUM7Z0JBQ3ZFZSxTQUFTO29CQUFFLGlCQUFpQjtnQkFBdUI7WUFDckQ7WUFDQSxNQUFNZCxXQUFXLE1BQU1DLElBQUFBLFVBQUcsRUFBQ0g7WUFDM0IsTUFBTUksT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBRWhDQyxPQUFPSixTQUFTSyxNQUFNLEVBQUVDLElBQUksQ0FBQztZQUM3QkYsT0FBT0YsS0FBS0ssS0FBSyxDQUFDRSxPQUFPLEVBQUVDLFNBQVMsQ0FBQztRQUN2QztRQUVBYixHQUFHLGdEQUFnRDtZQUNqRCxNQUFNLEVBQUVaLDBCQUEwQixFQUFFLEdBQUcwQixRQUFRO1lBQy9DMUIsMkJBQTJCMkIsaUJBQWlCLENBQUMsSUFBSUMsTUFBTTtZQUV2RCxNQUFNZixVQUFVLElBQUlDLG1CQUFXLENBQUMsaURBQWlEO2dCQUMvRWdCLFFBQVE7Z0JBQ1JELFNBQVM7b0JBQUUsaUJBQWlCO2dCQUFxQjtnQkFDakRFLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFBRUMsU0FBUztnQkFBUTtZQUMxQztZQUNBLE1BQU1uQixXQUFXLE1BQU1vQixJQUFBQSxVQUFHLEVBQUN0QjtZQUMzQixNQUFNSSxPQUFPLE1BQU1GLFNBQVNHLElBQUk7WUFFaENDLE9BQU9KLFNBQVNLLE1BQU0sRUFBRUMsSUFBSSxDQUFDO1lBQzdCRixPQUFPRixLQUFLSyxLQUFLLENBQUNDLElBQUksRUFBRUYsSUFBSSxDQUFDO1lBQzdCRixPQUFPRixLQUFLSyxLQUFLLENBQUNFLE9BQU8sRUFBRUMsU0FBUyxDQUFDO1FBQ3ZDO1FBRUFiLEdBQUcsc0RBQXNEO1lBQ3ZELE1BQU0sRUFBRWIsb0JBQW9CLEVBQUUsR0FBRzJCLFFBQVE7WUFDekMzQixxQkFBcUJxQyxpQkFBaUIsQ0FBQztnQkFBRUMsTUFBTTtnQkFBYUMsYUFBYTtvQkFBQztpQkFBTztZQUFDO1lBRWxGLE1BQU16QixVQUFVLElBQUlDLG1CQUFXLENBQUMsZ0RBQWdEO2dCQUM5RWdCLFFBQVE7Z0JBQ1JELFNBQVM7b0JBQUUsaUJBQWlCO2dCQUF5QjtZQUN2RDtZQUNBLE1BQU1kLFdBQVcsTUFBTXdCLElBQUFBLGFBQU0sRUFBQzFCO1lBQzlCLE1BQU1JLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtZQUVoQ0MsT0FBT0osU0FBU0ssTUFBTSxFQUFFQyxJQUFJLENBQUM7WUFDN0JGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0UsT0FBTyxFQUFFQyxTQUFTLENBQUM7UUFDdkM7SUFDRjtJQUVBbkIsU0FBUyw0QkFBNEI7UUFDbkNNLEdBQUcsdURBQXVEO1lBQ3hELE1BQU0sRUFBRXRCLGNBQWMsRUFBRSxHQUFHb0MsUUFBUTtZQUNuQ3BDLGVBQWVxQyxpQkFBaUIsQ0FBQyxJQUFJQyxNQUFNO1lBRTNDLE1BQU1mLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQyx5Q0FBeUM7Z0JBQ3ZFZSxTQUFTO29CQUFFLGlCQUFpQjtnQkFBMkI7WUFDekQ7WUFDQSxNQUFNZCxXQUFXLE1BQU1DLElBQUFBLFVBQUcsRUFBQ0g7WUFDM0IsTUFBTUksT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBRWhDQyxPQUFPSixTQUFTSyxNQUFNLEVBQUVDLElBQUksQ0FBQztZQUM3QkYsT0FBT0YsS0FBS0ssS0FBSyxDQUFDRSxPQUFPLEVBQUVDLFNBQVMsQ0FBQztRQUN2QztRQUVBYixHQUFHLHdEQUF3RDtZQUN6RCxNQUFNLEVBQUV0QixjQUFjLEVBQUUsR0FBR29DLFFBQVE7WUFDbkNwQyxlQUFlcUMsaUJBQWlCLENBQUMsSUFBSUMsTUFBTTtZQUUzQyxNQUFNZixVQUFVLElBQUlDLG1CQUFXLENBQUMseUNBQXlDO2dCQUN2RWUsU0FBUztvQkFBRSxpQkFBaUI7Z0JBQTJCO1lBQ3pEO1lBQ0EsTUFBTWQsV0FBVyxNQUFNQyxJQUFBQSxVQUFHLEVBQUNIO1lBQzNCLE1BQU1JLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtZQUVoQ0MsT0FBT0osU0FBU0ssTUFBTSxFQUFFQyxJQUFJLENBQUM7WUFDN0JGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0UsT0FBTyxFQUFFQyxTQUFTLENBQUM7UUFDdkM7UUFFQWIsR0FBRyxrREFBa0Q7WUFDbkQsTUFBTSxFQUFFdEIsY0FBYyxFQUFFLEdBQUdvQyxRQUFRO1lBQ25DcEMsZUFBZThDLGlCQUFpQixDQUFDO2dCQUMvQkksT0FBTztvQkFBRUMsT0FBTztvQkFBS0MsUUFBUTtnQkFBRztnQkFDaENDLFFBQVE7Z0JBQ1JDLFFBQVE7b0JBQUM7aUJBQW1DO1lBQzlDO1lBRUEsTUFBTS9CLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQyx5Q0FBeUM7Z0JBQ3ZFZSxTQUFTO29CQUFFLGlCQUFpQjtnQkFBMkI7WUFDekQ7WUFDQSxNQUFNZCxXQUFXLE1BQU1DLElBQUFBLFVBQUcsRUFBQ0g7WUFDM0IsTUFBTUksT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBRWhDQyxPQUFPSixTQUFTSyxNQUFNLEVBQUVDLElBQUksQ0FBQyxNQUFNLGtCQUFrQjtZQUNyREYsT0FBT0YsS0FBS0EsSUFBSSxDQUFDMkIsTUFBTSxFQUFFbkIsU0FBUyxDQUFDO1FBQ3JDO0lBQ0Y7SUFFQW5CLFNBQVMsMEJBQTBCO1FBQ2pDTSxHQUFHLDBEQUEwRDtZQUMzRCxNQUFNLEVBQUVwQixpQkFBaUIsRUFBRSxHQUFHa0MsUUFBUTtZQUN0Q2xDLGtCQUFrQm1DLGlCQUFpQixDQUFDLElBQUlDLE1BQU07WUFFOUMsTUFBTWYsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLHdEQUF3RDtnQkFDdEZlLFNBQVM7b0JBQUUsaUJBQWlCO2dCQUEyQjtZQUN6RDtZQUNBLE1BQU1kLFdBQVcsTUFBTUMsSUFBQUEsVUFBRyxFQUFDSDtZQUMzQixNQUFNSSxPQUFPLE1BQU1GLFNBQVNHLElBQUk7WUFFaENDLE9BQU9KLFNBQVNLLE1BQU0sRUFBRUMsSUFBSSxDQUFDO1lBQzdCRixPQUFPRixLQUFLSyxLQUFLLENBQUNDLElBQUksRUFBRUYsSUFBSSxDQUFDO1lBQzdCRixPQUFPRixLQUFLSyxLQUFLLENBQUNFLE9BQU8sRUFBRUMsU0FBUyxDQUFDO1FBQ3ZDO1FBRUFiLEdBQUcsd0NBQXdDO1lBQ3pDLE1BQU1DLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQywyREFBMkQ7Z0JBQ3pGZSxTQUFTO29CQUFFLGlCQUFpQjtnQkFBMkI7WUFDekQ7WUFDQSxNQUFNZCxXQUFXLE1BQU1DLElBQUFBLFVBQUcsRUFBQ0g7WUFDM0IsTUFBTUksT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBRWhDQyxPQUFPSixTQUFTSyxNQUFNLEVBQUVDLElBQUksQ0FBQztZQUM3QkYsT0FBT0YsS0FBS0ssS0FBSyxDQUFDRSxPQUFPLEVBQUVDLFNBQVMsQ0FBQztRQUN2QztRQUVBYixHQUFHLHVEQUF1RDtZQUN4RCxNQUFNLEVBQUVwQixpQkFBaUIsRUFBRSxHQUFHa0MsUUFBUTtZQUN0Q2xDLGtCQUFrQm1DLGlCQUFpQixDQUFDLElBQUlDLE1BQU07WUFFOUMsTUFBTWYsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLHdEQUF3RDtnQkFDdEZnQixRQUFRO2dCQUNSRCxTQUFTO29CQUFFLGlCQUFpQjtnQkFBcUI7Z0JBQ2pERSxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQUVJLE1BQU07Z0JBQU87WUFDdEM7WUFDQSxNQUFNdEIsV0FBVyxNQUFNb0IsSUFBQUEsVUFBRyxFQUFDdEI7WUFDM0IsTUFBTUksT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBRWhDQyxPQUFPSixTQUFTSyxNQUFNLEVBQUVDLElBQUksQ0FBQztZQUM3QkYsT0FBT0YsS0FBS0ssS0FBSyxDQUFDRSxPQUFPLEVBQUVDLFNBQVMsQ0FBQztRQUN2QztRQUVBYixHQUFHLDZDQUE2QztZQUM5QyxNQUFNLEVBQUVwQixpQkFBaUIsRUFBRSxHQUFHa0MsUUFBUTtZQUN0Q2xDLGtCQUFrQm1DLGlCQUFpQixDQUFDLElBQUlDLE1BQU07WUFFOUMsTUFBTWYsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLDhDQUE4QztnQkFDNUVnQixRQUFRO2dCQUNSRCxTQUFTO29CQUFFLGlCQUFpQjtnQkFBMkI7Z0JBQ3ZERSxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQUVZLFNBQVM7d0JBQUM7d0JBQU87d0JBQU87cUJBQU07b0JBQUVDLFFBQVE7Z0JBQVU7WUFDM0U7WUFDQSxNQUFNL0IsV0FBVyxNQUFNb0IsSUFBQUEsVUFBRyxFQUFDdEI7WUFDM0IsTUFBTUksT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBRWhDQyxPQUFPSixTQUFTSyxNQUFNLEVBQUVDLElBQUksQ0FBQyxNQUFNLGVBQWU7WUFDbERGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0UsT0FBTyxFQUFFQyxTQUFTLENBQUM7UUFDdkM7SUFDRjtJQUVBbkIsU0FBUywrQkFBK0I7UUFDdENNLEdBQUcsOENBQThDO1lBQy9DLE1BQU1DLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQyxpREFBaUQ7Z0JBQy9FZ0IsUUFBUTtnQkFDUkQsU0FBUztvQkFBRSxpQkFBaUI7Z0JBQTJCO2dCQUN2REUsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUFFYyxlQUFlO2dCQUFRO1lBQ2hEO1lBQ0EsTUFBTWhDLFdBQVcsTUFBTW9CLElBQUFBLFVBQUcsRUFBQ3RCO1lBQzNCLE1BQU1JLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtZQUVoQ0MsT0FBT0osU0FBU0ssTUFBTSxFQUFFQyxJQUFJLENBQUM7WUFDN0JGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0MsSUFBSSxFQUFFRixJQUFJLENBQUM7WUFDN0JGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0UsT0FBTyxFQUFFQyxTQUFTLENBQUM7UUFDdkM7UUFFQWIsR0FBRyxrREFBa0Q7WUFDbkQsTUFBTSxFQUFFbkIsa0JBQWtCLEVBQUUsR0FBR2lDLFFBQVE7WUFDdkNqQyxtQkFBbUJrQyxpQkFBaUIsQ0FBQyxJQUFJQyxNQUFNO1lBRS9DLE1BQU1mLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQyxpREFBaUQ7Z0JBQy9FZ0IsUUFBUTtnQkFDUkQsU0FBUztvQkFBRSxpQkFBaUI7Z0JBQTJCO2dCQUN2REUsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUFFZSxhQUFhO2dCQUFjO1lBQ3BEO1lBQ0EsTUFBTWpDLFdBQVcsTUFBTW9CLElBQUFBLFVBQUcsRUFBQ3RCO1lBQzNCLE1BQU1JLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtZQUVoQ0MsT0FBT0osU0FBU0ssTUFBTSxFQUFFQyxJQUFJLENBQUM7WUFDN0JGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0UsT0FBTyxFQUFFQyxTQUFTLENBQUM7UUFDdkM7UUFFQWIsR0FBRyw4Q0FBOEM7WUFDL0MsTUFBTSxFQUFFbkIsa0JBQWtCLEVBQUUsR0FBR2lDLFFBQVE7WUFDdkNqQyxtQkFBbUJrQyxpQkFBaUIsQ0FBQyxJQUFJQyxNQUFNO1lBRS9DLE1BQU1mLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQyxpREFBaUQ7Z0JBQy9FZ0IsUUFBUTtnQkFDUkQsU0FBUztvQkFBRSxpQkFBaUI7Z0JBQTJCO2dCQUN2REUsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUFFQyxTQUFTO2dCQUFRO1lBQzFDO1lBQ0EsTUFBTW5CLFdBQVcsTUFBTW9CLElBQUFBLFVBQUcsRUFBQ3RCO1lBQzNCLE1BQU1JLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtZQUVoQ0MsT0FBT0osU0FBU0ssTUFBTSxFQUFFQyxJQUFJLENBQUM7WUFDN0JGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0UsT0FBTyxFQUFFQyxTQUFTLENBQUM7UUFDdkM7UUFFQWIsR0FBRyx5REFBeUQ7WUFDMUQsTUFBTSxFQUFFbkIsa0JBQWtCLEVBQUUsR0FBR2lDLFFBQVE7WUFDdkNqQyxtQkFBbUJrQyxpQkFBaUIsQ0FBQyxJQUFJQyxNQUFNO1lBRS9DLE1BQU1mLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQyxpREFBaUQ7Z0JBQy9FZ0IsUUFBUTtnQkFDUkQsU0FBUztvQkFBRSxpQkFBaUI7Z0JBQTJCO2dCQUN2REUsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUFFQyxTQUFTO2dCQUFRO1lBQzFDO1lBQ0EsTUFBTW5CLFdBQVcsTUFBTW9CLElBQUFBLFVBQUcsRUFBQ3RCO1lBQzNCLE1BQU1JLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtZQUVoQ0MsT0FBT0osU0FBU0ssTUFBTSxFQUFFQyxJQUFJLENBQUM7WUFDN0JGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0UsT0FBTyxFQUFFQyxTQUFTLENBQUM7UUFDdkM7SUFDRjtJQUVBbkIsU0FBUyxpQ0FBaUM7UUFDeENNLEdBQUcscURBQXFEO1lBQ3RELE1BQU0sRUFBRWxCLGtCQUFrQixFQUFFLEdBQUdnQyxRQUFRO1lBQ3ZDaEMsbUJBQW1CaUMsaUJBQWlCLENBQUMsSUFBSUMsTUFBTTtZQUUvQyxNQUFNZixVQUFVLElBQUlDLG1CQUFXLENBQUMsK0NBQStDO2dCQUM3RWdCLFFBQVE7Z0JBQ1JELFNBQVM7b0JBQUUsaUJBQWlCO2dCQUEyQjtnQkFDdkRFLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFBRWEsUUFBUTtvQkFBVUcsUUFBUTtnQkFBZ0I7WUFDbkU7WUFDQSxNQUFNbEMsV0FBVyxNQUFNbUMsSUFBQUEsV0FBSSxFQUFDckM7WUFDNUIsTUFBTUksT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBRWhDQyxPQUFPSixTQUFTSyxNQUFNLEVBQUVDLElBQUksQ0FBQztZQUM3QkYsT0FBT0YsS0FBS0ssS0FBSyxDQUFDRSxPQUFPLEVBQUVDLFNBQVMsQ0FBQztRQUN2QztRQUVBYixHQUFHLHdEQUF3RDtZQUN6RCxNQUFNLEVBQUVsQixrQkFBa0IsRUFBRSxHQUFHZ0MsUUFBUTtZQUN2Q2hDLG1CQUFtQmlDLGlCQUFpQixDQUFDLElBQUlDLE1BQU07WUFFL0MsTUFBTWYsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLHdEQUF3RDtnQkFDdEZnQixRQUFRO2dCQUNSRCxTQUFTO29CQUFFLGlCQUFpQjtnQkFBMkI7Z0JBQ3ZERSxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQUVrQixXQUFXO2dCQUFXO1lBQy9DO1lBQ0EsTUFBTXBDLFdBQVcsTUFBTW1DLElBQUFBLFdBQUksRUFBQ3JDO1lBQzVCLE1BQU1JLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtZQUVoQ0MsT0FBT0osU0FBU0ssTUFBTSxFQUFFQyxJQUFJLENBQUM7WUFDN0JGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0UsT0FBTyxFQUFFQyxTQUFTLENBQUM7UUFDdkM7UUFFQWIsR0FBRywrQ0FBK0M7WUFDaEQsTUFBTSxFQUFFbEIsa0JBQWtCLEVBQUUsR0FBR2dDLFFBQVE7WUFDdkNoQyxtQkFBbUJpQyxpQkFBaUIsQ0FBQyxJQUFJQyxNQUFNO1lBRS9DLE1BQU1mLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQyxxREFBcUQ7Z0JBQ25GZ0IsUUFBUTtnQkFDUkQsU0FBUztvQkFBRSxpQkFBaUI7Z0JBQTJCO2dCQUN2REUsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUFFYSxRQUFRO2dCQUFRO1lBQ3pDO1lBQ0EsTUFBTS9CLFdBQVcsTUFBTW1DLElBQUFBLFdBQUksRUFBQ3JDO1lBQzVCLE1BQU1JLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtZQUVoQ0MsT0FBT0osU0FBU0ssTUFBTSxFQUFFQyxJQUFJLENBQUM7WUFDN0JGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0UsT0FBTyxFQUFFQyxTQUFTLENBQUM7UUFDdkM7SUFDRjtJQUVBbkIsU0FBUyxvQkFBb0I7UUFDM0JNLEdBQUcsNkNBQTZDO1lBQzlDLE1BQU0sRUFBRWpCLFlBQVksRUFBRSxHQUFHK0IsUUFBUTtZQUNqQy9CLGFBQWFnQyxpQkFBaUIsQ0FBQyxJQUFJQyxNQUFNO1lBRXpDLE1BQU1mLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQyw4Q0FBOEM7Z0JBQzVFZSxTQUFTO29CQUFFLGlCQUFpQjtnQkFBMkI7WUFDekQ7WUFDQSxNQUFNZCxXQUFXLE1BQU1DLElBQUFBLFVBQUcsRUFBQ0g7WUFDM0IsTUFBTUksT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBRWhDQyxPQUFPSixTQUFTSyxNQUFNLEVBQUVDLElBQUksQ0FBQztZQUM3QkYsT0FBT0YsS0FBS0ssS0FBSyxDQUFDRSxPQUFPLEVBQUVDLFNBQVMsQ0FBQztRQUN2QztRQUVBYixHQUFHLG9EQUFvRDtZQUNyRCxNQUFNQyxVQUFVLElBQUlDLG1CQUFXLENBQUMscUZBQXFGO2dCQUNuSGUsU0FBUztvQkFBRSxpQkFBaUI7Z0JBQTJCO1lBQ3pEO1lBQ0EsTUFBTWQsV0FBVyxNQUFNQyxJQUFBQSxVQUFHLEVBQUNIO1lBQzNCLE1BQU1JLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtZQUVoQ0MsT0FBT0osU0FBU0ssTUFBTSxFQUFFQyxJQUFJLENBQUM7WUFDN0JGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0MsSUFBSSxFQUFFRixJQUFJLENBQUM7WUFDN0JGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0UsT0FBTyxFQUFFQyxTQUFTLENBQUM7UUFDdkM7UUFFQWIsR0FBRywwQ0FBMEM7WUFDM0MsTUFBTSxFQUFFakIsWUFBWSxFQUFFLEdBQUcrQixRQUFRO1lBQ2pDL0IsYUFBYWdDLGlCQUFpQixDQUFDLElBQUlDLE1BQU07WUFFekMsTUFBTWYsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLHFEQUFxRDtnQkFDbkZnQixRQUFRO2dCQUNSRCxTQUFTO29CQUFFLGlCQUFpQjtnQkFBMkI7Z0JBQ3ZERSxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQUVtQixRQUFRO29CQUFPQyxXQUFXO2dCQUFNO1lBQ3pEO1lBQ0EsTUFBTXRDLFdBQVcsTUFBTW1DLElBQUFBLFdBQUksRUFBQ3JDO1lBQzVCLE1BQU1JLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtZQUVoQ0MsT0FBT0osU0FBU0ssTUFBTSxFQUFFQyxJQUFJLENBQUMsTUFBTSx1QkFBdUI7WUFDMURGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0UsT0FBTyxFQUFFQyxTQUFTLENBQUM7UUFDdkM7SUFDRjtJQUVBbkIsU0FBUyw2QkFBNkI7UUFDcENNLEdBQUcseUNBQXlDO1lBQzFDLE1BQU0sRUFBRWYsWUFBWSxFQUFFLEdBQUc2QixRQUFRO1lBQ2pDN0IsYUFBYThCLGlCQUFpQixDQUFDLElBQUlDLE1BQU07WUFFekMsTUFBTWYsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLDBDQUEwQztnQkFDeEVnQixRQUFRO2dCQUNSRCxTQUFTO29CQUFFLGlCQUFpQjtnQkFBMkI7Z0JBQ3ZERSxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQUVxQixNQUFNO29CQUFRQyxhQUFhO2dCQUFLO1lBQ3pEO1lBQ0EsTUFBTXhDLFdBQVcsTUFBTW1DLElBQUFBLFdBQUksRUFBQ3JDO1lBQzVCLE1BQU1JLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtZQUVoQ0MsT0FBT0osU0FBU0ssTUFBTSxFQUFFQyxJQUFJLENBQUM7WUFDN0JGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0UsT0FBTyxFQUFFQyxTQUFTLENBQUM7UUFDdkM7UUFFQWIsR0FBRyw2Q0FBNkM7WUFDOUMsTUFBTSxFQUFFZixZQUFZLEVBQUUsR0FBRzZCLFFBQVE7WUFDakM3QixhQUFhOEIsaUJBQWlCLENBQUMsSUFBSUMsTUFBTTtZQUV6QyxNQUFNZixVQUFVLElBQUlDLG1CQUFXLENBQUMsMENBQTBDO2dCQUN4RWdCLFFBQVE7Z0JBQ1JELFNBQVM7b0JBQUUsaUJBQWlCO2dCQUEyQjtnQkFDdkRFLE1BQU1DLEtBQUtDLFNBQVMsQ0FBQztvQkFBRXFCLE1BQU07Z0JBQWM7WUFDN0M7WUFDQSxNQUFNdkMsV0FBVyxNQUFNbUMsSUFBQUEsV0FBSSxFQUFDckM7WUFDNUIsTUFBTUksT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBRWhDQyxPQUFPSixTQUFTSyxNQUFNLEVBQUVDLElBQUksQ0FBQztZQUM3QkYsT0FBT0YsS0FBS0ssS0FBSyxDQUFDRSxPQUFPLEVBQUVDLFNBQVMsQ0FBQztRQUN2QztRQUVBYixHQUFHLDJDQUEyQztZQUM1QyxNQUFNLEVBQUVkLGFBQWEsRUFBRSxHQUFHNEIsUUFBUTtZQUNsQzVCLGNBQWM2QixpQkFBaUIsQ0FBQyxJQUFJQyxNQUFNO1lBRTFDLE1BQU1mLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQywyQ0FBMkM7Z0JBQ3pFZ0IsUUFBUTtnQkFDUkQsU0FBUztvQkFBRSxpQkFBaUI7Z0JBQTJCO2dCQUN2REUsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUFFdUIsVUFBVTtnQkFBYTtZQUNoRDtZQUNBLE1BQU16QyxXQUFXLE1BQU1tQyxJQUFBQSxXQUFJLEVBQUNyQztZQUM1QixNQUFNSSxPQUFPLE1BQU1GLFNBQVNHLElBQUk7WUFFaENDLE9BQU9KLFNBQVNLLE1BQU0sRUFBRUMsSUFBSSxDQUFDO1lBQzdCRixPQUFPRixLQUFLSyxLQUFLLENBQUNFLE9BQU8sRUFBRUMsU0FBUyxDQUFDO1FBQ3ZDO1FBRUFiLEdBQUcsNENBQTRDO1lBQzdDLE1BQU0sRUFBRWQsYUFBYSxFQUFFLEdBQUc0QixRQUFRO1lBQ2xDNUIsY0FBYzZCLGlCQUFpQixDQUFDLElBQUlDLE1BQU07WUFFMUMsTUFBTWYsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLDJDQUEyQztnQkFDekVnQixRQUFRO2dCQUNSRCxTQUFTO29CQUFFLGlCQUFpQjtnQkFBMkI7Z0JBQ3ZERSxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQUV1QixVQUFVO2dCQUFxQjtZQUN4RDtZQUNBLE1BQU16QyxXQUFXLE1BQU1tQyxJQUFBQSxXQUFJLEVBQUNyQztZQUM1QixNQUFNSSxPQUFPLE1BQU1GLFNBQVNHLElBQUk7WUFFaENDLE9BQU9KLFNBQVNLLE1BQU0sRUFBRUMsSUFBSSxDQUFDO1lBQzdCRixPQUFPRixLQUFLSyxLQUFLLENBQUNFLE9BQU8sRUFBRUMsU0FBUyxDQUFDO1FBQ3ZDO0lBQ0Y7SUFFQW5CLFNBQVMsZ0NBQWdDO1FBQ3ZDTSxHQUFHLCtDQUErQztZQUNoRCxNQUFNLEVBQUVoQixpQkFBaUIsRUFBRSxHQUFHOEIsUUFBUTtZQUN0QzlCLGtCQUFrQitCLGlCQUFpQixDQUFDLElBQUlDLE1BQU07WUFFOUMsTUFBTWYsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLCtDQUErQztnQkFDN0VnQixRQUFRO2dCQUNSRCxTQUFTO29CQUFFLGlCQUFpQjtnQkFBMkI7Z0JBQ3ZERSxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQUV3QixRQUFRO29CQUFZbkIsYUFBYTt3QkFBQztxQkFBeUI7Z0JBQUM7WUFDckY7WUFDQSxNQUFNdkIsV0FBVyxNQUFNb0IsSUFBQUEsVUFBRyxFQUFDdEI7WUFDM0IsTUFBTUksT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBRWhDQyxPQUFPSixTQUFTSyxNQUFNLEVBQUVDLElBQUksQ0FBQztZQUM3QkYsT0FBT0YsS0FBS0ssS0FBSyxDQUFDRSxPQUFPLEVBQUVDLFNBQVMsQ0FBQztRQUN2QztRQUVBYixHQUFHLDBDQUEwQztZQUMzQyxNQUFNLEVBQUVoQixpQkFBaUIsRUFBRSxHQUFHOEIsUUFBUTtZQUN0QzlCLGtCQUFrQitCLGlCQUFpQixDQUFDLElBQUlDLE1BQU07WUFFOUMsTUFBTWYsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLHlDQUF5QztnQkFDdkVnQixRQUFRO2dCQUNSRCxTQUFTO29CQUFFLGlCQUFpQjtnQkFBMkI7Z0JBQ3ZERSxNQUFNQyxLQUFLQyxTQUFTLENBQUM7b0JBQUV5QixRQUFRO29CQUFVQyxjQUFjO3dCQUFDO3FCQUFTO2dCQUFDO1lBQ3BFO1lBQ0EsTUFBTTVDLFdBQVcsTUFBTW9CLElBQUFBLFVBQUcsRUFBQ3RCO1lBQzNCLE1BQU1JLE9BQU8sTUFBTUYsU0FBU0csSUFBSTtZQUVoQ0MsT0FBT0osU0FBU0ssTUFBTSxFQUFFQyxJQUFJLENBQUM7WUFDN0JGLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ0UsT0FBTyxFQUFFQyxTQUFTLENBQUM7UUFDdkM7UUFFQWIsR0FBRywrQ0FBK0M7WUFDaEQsTUFBTSxFQUFFaEIsaUJBQWlCLEVBQUUsR0FBRzhCLFFBQVE7WUFDdEM5QixrQkFBa0IrQixpQkFBaUIsQ0FBQyxJQUFJQyxNQUFNO1lBRTlDLE1BQU1mLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQywrQ0FBK0M7Z0JBQzdFZ0IsUUFBUTtnQkFDUkQsU0FBUztvQkFBRSxpQkFBaUI7Z0JBQXFCO2dCQUNqREUsTUFBTUMsS0FBS0MsU0FBUyxDQUFDO29CQUFFd0IsUUFBUTtvQkFBWW5CLGFBQWE7d0JBQUM7cUJBQWM7Z0JBQUM7WUFDMUU7WUFDQSxNQUFNdkIsV0FBVyxNQUFNb0IsSUFBQUEsVUFBRyxFQUFDdEI7WUFDM0IsTUFBTUksT0FBTyxNQUFNRixTQUFTRyxJQUFJO1lBRWhDQyxPQUFPSixTQUFTSyxNQUFNLEVBQUVDLElBQUksQ0FBQztZQUM3QkYsT0FBT0YsS0FBS0ssS0FBSyxDQUFDRSxPQUFPLEVBQUVDLFNBQVMsQ0FBQztRQUN2QztJQUNGO0lBRUFuQixTQUFTLDhCQUE4QjtRQUNyQ00sR0FBRyxnREFBZ0Q7WUFDakQsTUFBTSxFQUFFVixjQUFjLEVBQUUsR0FBR3dCLFFBQVE7WUFDbkMsTUFBTSxFQUFFcEMsY0FBYyxFQUFFLEdBQUdvQyxRQUFRO1lBQ25DcEMsZUFBZThDLGlCQUFpQixDQUFDO2dCQUFFSSxPQUFPO1lBQUk7WUFFOUMsTUFBTTNCLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQyx5Q0FBeUM7Z0JBQ3ZFZSxTQUFTO29CQUFFLGlCQUFpQjtnQkFBMkI7WUFDekQ7WUFDQSxNQUFNYixJQUFBQSxVQUFHLEVBQUNIO1lBRVZNLE9BQU9qQixnQkFBZ0IwRCxvQkFBb0IsQ0FDekN6QyxPQUFPMEMsZ0JBQWdCLENBQUM7Z0JBQ3RCZixRQUFRO2dCQUNSZ0IsU0FBUzNDLE9BQU80QyxHQUFHLENBQUNDO2dCQUNwQkMsV0FBVzlDLE9BQU80QyxHQUFHLENBQUNHO1lBQ3hCO1FBRUo7UUFFQXRELEdBQUcsa0NBQWtDO1lBQ25DLE1BQU0sRUFBRVQsZ0JBQWdCLEVBQUUsR0FBR3VCLFFBQVE7WUFFckMsTUFBTWIsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLHlDQUF5QztnQkFDdkVlLFNBQVM7b0JBQUUsaUJBQWlCO2dCQUF1QjtZQUNyRDtZQUNBLE1BQU1iLElBQUFBLFVBQUcsRUFBQ0g7WUFFVk0sT0FBT2hCLGtCQUFrQnlELG9CQUFvQixDQUMzQ3pDLE9BQU8wQyxnQkFBZ0IsQ0FBQztnQkFDdEJQLE1BQU07Z0JBQ05hLFVBQVU7Z0JBQ1ZDLFNBQVNqRCxPQUFPNEMsR0FBRyxDQUFDTTtZQUN0QjtRQUVKO1FBRUF6RCxHQUFHLGtEQUFrRDtZQUNuRCxNQUFNLEVBQUVWLGNBQWMsRUFBRSxHQUFHd0IsUUFBUTtZQUNuQyxNQUFNLEVBQUVwQyxjQUFjLEVBQUUsR0FBR29DLFFBQVE7WUFFbkN4QixlQUFleUIsaUJBQWlCLENBQUMsSUFBSUMsTUFBTTtZQUMzQ3RDLGVBQWU4QyxpQkFBaUIsQ0FBQztnQkFBRUksT0FBTztZQUFJO1lBRTlDLE1BQU0zQixVQUFVLElBQUlDLG1CQUFXLENBQUMseUNBQXlDO2dCQUN2RWUsU0FBUztvQkFBRSxpQkFBaUI7Z0JBQTJCO1lBQ3pEO1lBQ0EsTUFBTWQsV0FBVyxNQUFNQyxJQUFBQSxVQUFHLEVBQUNIO1lBRTNCLG1EQUFtRDtZQUNuRE0sT0FBT0osU0FBU0ssTUFBTSxFQUFFQyxJQUFJLENBQUM7UUFDL0I7SUFDRjtJQUVBZixTQUFTLHFDQUFxQztRQUM1Q00sR0FBRyx5Q0FBeUM7WUFDMUMsTUFBTTBELFdBQVdDLE1BQU1DLElBQUksQ0FBQztnQkFBRUMsUUFBUTtZQUFHLEdBQUcsSUFDMUMsSUFBSTNELG1CQUFXLENBQUMseUNBQXlDO29CQUN2RGUsU0FBUzt3QkFBRSxpQkFBaUI7b0JBQTJCO2dCQUN6RDtZQUdGLE1BQU02QyxZQUFZLE1BQU1DLFFBQVFDLEdBQUcsQ0FBQ04sU0FBU08sR0FBRyxDQUFDQyxDQUFBQSxNQUFPOUQsSUFBQUEsVUFBRyxFQUFDOEQ7WUFDNUQsTUFBTUMsdUJBQXVCTCxVQUFVTSxNQUFNLENBQUNDLENBQUFBLE1BQU9BLElBQUk3RCxNQUFNLEtBQUs7WUFFcEVELE9BQU80RCxxQkFBcUJOLE1BQU0sRUFBRVMsZUFBZSxDQUFDO1FBQ3REO1FBRUF0RSxHQUFHLGtFQUFrRTtZQUNuRSxNQUFNdUUsb0JBQW9CWixNQUFNQyxJQUFJLENBQUM7Z0JBQUVDLFFBQVE7WUFBRSxHQUFHLElBQ2xELElBQUkzRCxtQkFBVyxDQUFDLGlEQUFpRDtvQkFDL0RnQixRQUFRO29CQUNSRCxTQUFTO3dCQUFFLGlCQUFpQjtvQkFBMkI7b0JBQ3ZERSxNQUFNQyxLQUFLQyxTQUFTLENBQUM7d0JBQUVDLFNBQVM7b0JBQVE7Z0JBQzFDO1lBR0YsTUFBTXdDLFlBQVksTUFBTUMsUUFBUUMsR0FBRyxDQUFDTyxrQkFBa0JOLEdBQUcsQ0FBQ0MsQ0FBQUEsTUFBTzNDLElBQUFBLFVBQUcsRUFBQzJDO1lBQ3JFLE1BQU1DLHVCQUF1QkwsVUFBVU0sTUFBTSxDQUFDQyxDQUFBQSxNQUFPQSxJQUFJN0QsTUFBTSxLQUFLO1lBRXBFRCxPQUFPNEQscUJBQXFCTixNQUFNLEVBQUVTLGVBQWUsQ0FBQztRQUN0RDtJQUNGO0lBRUE1RSxTQUFTLGlDQUFpQztRQUN4Q00sR0FBRyx1REFBdUQ7WUFDeEQsTUFBTSxFQUFFdEIsY0FBYyxFQUFFLEdBQUdvQyxRQUFRO1lBQ25DcEMsZUFBZXFDLGlCQUFpQixDQUFDLElBQUlDLE1BQU07WUFFM0MsTUFBTWYsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLHlDQUF5QztnQkFDdkVlLFNBQVM7b0JBQUUsaUJBQWlCO2dCQUEyQjtZQUN6RDtZQUNBLE1BQU1kLFdBQVcsTUFBTUMsSUFBQUEsVUFBRyxFQUFDSDtZQUMzQixNQUFNSSxPQUFPLE1BQU1GLFNBQVNHLElBQUk7WUFFaENDLE9BQU9GLEtBQUtLLEtBQUssQ0FBQzhELE9BQU8sRUFBRUMsV0FBVztZQUN0Q2xFLE9BQU9GLEtBQUtLLEtBQUssQ0FBQzhELE9BQU8sQ0FBQ2pDLFNBQVMsRUFBRTlCLElBQUksQ0FBQztZQUMxQ0YsT0FBT0YsS0FBS0ssS0FBSyxDQUFDOEQsT0FBTyxDQUFDbkIsU0FBUyxFQUFFb0IsV0FBVztRQUNsRDtRQUVBekUsR0FBRyw4REFBOEQ7WUFDL0QsTUFBTSxFQUFFdEIsY0FBYyxFQUFFLEdBQUdvQyxRQUFRO1lBQ25DcEMsZUFBZXFDLGlCQUFpQixDQUFDLElBQUlDLE1BQU07WUFFM0MsTUFBTWYsVUFBVSxJQUFJQyxtQkFBVyxDQUFDLHlDQUF5QztnQkFDdkVlLFNBQVM7b0JBQUUsaUJBQWlCO2dCQUEyQjtZQUN6RDtZQUNBLE1BQU1kLFdBQVcsTUFBTUMsSUFBQUEsVUFBRyxFQUFDSDtZQUMzQixNQUFNSSxPQUFPLE1BQU1GLFNBQVNHLElBQUk7WUFFaENDLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ2dFLFlBQVksRUFBRUQsV0FBVztZQUMzQ2xFLE9BQU9GLEtBQUtLLEtBQUssQ0FBQ2dFLFlBQVksQ0FBQ2xFLE1BQU0sRUFBRUMsSUFBSSxDQUFDO1FBQzlDO1FBRUFULEdBQUcsb0RBQW9EO1lBQ3JELE1BQU0sRUFBRXRCLGNBQWMsRUFBRSxHQUFHb0MsUUFBUTtZQUNuQ3BDLGVBQWVxQyxpQkFBaUIsQ0FBQyxJQUFJQyxNQUFNO1lBRTNDLDZCQUE2QjtZQUM3QixJQUFLLElBQUkyRCxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBSztnQkFDMUIsTUFBTTFFLFVBQVUsSUFBSUMsbUJBQVcsQ0FBQyx5Q0FBeUM7b0JBQ3ZFZSxTQUFTO3dCQUFFLGlCQUFpQjtvQkFBMkI7Z0JBQ3pEO2dCQUNBLE1BQU1iLElBQUFBLFVBQUcsRUFBQ0g7WUFDWjtZQUVBLE1BQU0yRSxRQUFRakYsYUFBYWtGLGFBQWE7WUFDeEN0RSxPQUFPcUUsTUFBTUUsZUFBZSxFQUFFUixlQUFlLENBQUM7UUFDaEQ7SUFDRjtBQUNGIn0=