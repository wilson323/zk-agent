{"file":"E:\\zk-agent\\__tests__\\lib\\di\\container.test.ts","mappings":"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","names":[],"sources":["E:\\zk-agent\\__tests__\\lib\\di\\container.test.ts"],"sourcesContent":["/**\r\n * @file 依赖注入容器测试\r\n * @description 测试依赖注入容器的功能\r\n * @author ZK-Agent Team\r\n * @date 2024-12-20\r\n */\r\n\r\nimport 'reflect-metadata';\r\nimport { Container, ServiceLifetime, container, TYPES, inject, injectable } from '../../../lib/di/container';\r\n\r\n// 测试接口和实现\r\ninterface ITestService {\r\n  getValue(): string;\r\n}\r\n\r\nclass TestService implements ITestService {\r\n  getValue(): string {\r\n    return 'test-value';\r\n  }\r\n}\r\n\r\ninterface ITestDependency {\r\n  getName(): string;\r\n}\r\n\r\nclass TestDependency implements ITestDependency {\r\n  getName(): string {\r\n    return 'test-dependency';\r\n  }\r\n}\r\n\r\n// 带依赖的服务\r\nclass ServiceWithDependency {\r\n  constructor(private dependency: ITestDependency) {}\r\n  \r\n  getDependencyName(): string {\r\n    return this.dependency.getName();\r\n  }\r\n}\r\n\r\n// 使用装饰器的服务\r\n@injectable()\r\nclass DecoratedService {\r\n  constructor(\r\n    @inject(Symbol.for('TestDependency')) private dependency: ITestDependency\r\n  ) {}\r\n  \r\n  getDependencyName(): string {\r\n    return this.dependency.getName();\r\n  }\r\n}\r\n\r\ndescribe('Container', () => {\r\n  let testContainer: Container;\r\n  \r\n  beforeEach(() => {\r\n    // 创建新的容器实例，避免测试间相互影响\r\n    testContainer = new Container();\r\n  });\r\n  \r\n  afterEach(() => {\r\n    // 清理容器\r\n    testContainer.dispose();\r\n  });\r\n  \r\n  test('应该能够注册和解析单例服务', () => {\r\n    // 注册服务\r\n    const serviceToken = Symbol.for('TestService');\r\n    testContainer.registerSingleton(serviceToken, () => new TestService());\r\n    \r\n    // 解析服务\r\n    const service1 = testContainer.resolve<ITestService>(serviceToken);\r\n    const service2 = testContainer.resolve<ITestService>(serviceToken);\r\n    \r\n    // 验证服务实例\r\n    expect(service1).toBeDefined();\r\n    expect(service1.getValue()).toBe('test-value');\r\n    \r\n    // 验证单例行为\r\n    expect(service1).toBe(service2);\r\n  });\r\n  \r\n  test('应该能够注册和解析瞬态服务', () => {\r\n    // 注册服务\r\n    const serviceToken = Symbol.for('TestService');\r\n    testContainer.registerTransient(serviceToken, () => new TestService());\r\n    \r\n    // 解析服务\r\n    const service1 = testContainer.resolve<ITestService>(serviceToken);\r\n    const service2 = testContainer.resolve<ITestService>(serviceToken);\r\n    \r\n    // 验证服务实例\r\n    expect(service1).toBeDefined();\r\n    expect(service1.getValue()).toBe('test-value');\r\n    \r\n    // 验证瞬态行为\r\n    expect(service1).not.toBe(service2);\r\n  });\r\n  \r\n  test('应该能够解析带依赖的服务', () => {\r\n    // 注册依赖\r\n    const dependencyToken = Symbol.for('TestDependency');\r\n    testContainer.registerSingleton(dependencyToken, () => new TestDependency());\r\n    \r\n    // 注册带依赖的服务\r\n    const serviceToken = Symbol.for('ServiceWithDependency');\r\n    testContainer.registerSingleton(serviceToken, (container) => {\r\n      const dependency = container.resolve<ITestDependency>(dependencyToken);\r\n      return new ServiceWithDependency(dependency);\r\n    });\r\n    \r\n    // 解析服务\r\n    const service = testContainer.resolve<ServiceWithDependency>(serviceToken);\r\n    \r\n    // 验证服务实例\r\n    expect(service).toBeDefined();\r\n    expect(service.getDependencyName()).toBe('test-dependency');\r\n  });\r\n  \r\n  test('当服务未注册时应该抛出错误', () => {\r\n    // 尝试解析未注册的服务\r\n    const unknownToken = Symbol.for('UnknownService');\r\n    \r\n    // 验证抛出错误\r\n    expect(() => {\r\n      testContainer.resolve(unknownToken);\r\n    }).toThrow();\r\n  });\r\n  \r\n  test('应该能够检查服务是否已注册', () => {\r\n    // 注册服务\r\n    const serviceToken = Symbol.for('TestService');\r\n    testContainer.registerSingleton(serviceToken, () => new TestService());\r\n    \r\n    // 验证注册状态\r\n    expect(testContainer.isRegistered(serviceToken)).toBe(true);\r\n    expect(testContainer.isRegistered(Symbol.for('UnknownService'))).toBe(false);\r\n  });\r\n  \r\n  test('应该能够使用装饰器注入依赖', () => {\r\n    // 注册依赖\r\n    const dependencyToken = Symbol.for('TestDependency');\r\n    testContainer.registerSingleton(dependencyToken, () => new TestDependency());\r\n    \r\n    // 创建使用装饰器的服务实例\r\n    const decoratedService = new DecoratedService(testContainer.resolve(dependencyToken));\r\n    \r\n    // 验证依赖注入\r\n    expect(decoratedService.getDependencyName()).toBe('test-dependency');\r\n  });\r\n});\r\n\r\ndescribe('全局容器和装饰器', () => {\r\n  // 在测试前备份原始TYPES\r\n  const originalTypes = { ...TYPES };\r\n  \r\n  beforeAll(() => {\r\n    // 添加测试类型\r\n    (TYPES as any).TestDependency = Symbol.for('TestDependency');\r\n    (TYPES as any).DecoratedServiceWithToken = Symbol.for('DecoratedServiceWithToken');\r\n  });\r\n  \r\n  afterAll(() => {\r\n    // 恢复原始TYPES\r\n    Object.keys(TYPES).forEach(key => {\r\n      if (!originalTypes.hasOwnProperty(key)) {\r\n        delete (TYPES as any)[key];\r\n      }\r\n    });\r\n    \r\n    // 清理容器\r\n    container.dispose();\r\n  });\r\n  \r\n  test('应该能够使用全局容器注册和解析服务', () => {\r\n    // 注册服务到全局容器\r\n    container.registerSingleton(TYPES.TestDependency, () => new TestDependency());\r\n    \r\n    // 解析服务\r\n    const dependency = container.resolve<ITestDependency>(TYPES.TestDependency);\r\n    \r\n    // 验证服务实例\r\n    expect(dependency).toBeDefined();\r\n    expect(dependency.getName()).toBe('test-dependency');\r\n  });\r\n  \r\n  test('应该能够使用injectable装饰器自动注册服务', () => {\r\n    // 使用装饰器自动注册的服务\r\n    @injectable(TYPES.DecoratedServiceWithToken)\r\n    class DecoratedServiceWithToken {\r\n      constructor(\r\n        @inject(TYPES.TestDependency) private dependency: ITestDependency\r\n      ) {}\r\n      \r\n      getDependencyName(): string {\r\n        return this.dependency.getName();\r\n      }\r\n    }\r\n    \r\n    // 解析服务\r\n    const service = container.resolve<DecoratedServiceWithToken>(TYPES.DecoratedServiceWithToken);\r\n    \r\n    // 验证服务实例\r\n    expect(service).toBeDefined();\r\n    expect(service.getDependencyName()).toBe('test-dependency');\r\n  });\r\n});\r\n"],"version":3}